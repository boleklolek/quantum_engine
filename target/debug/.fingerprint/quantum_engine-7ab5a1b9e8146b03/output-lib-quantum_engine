{"$message_type":"diagnostic","message":"unused import: `BasisShell`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/system/basis_loader.rs","byte_start":222,"byte_end":232,"line_start":6,"line_end":6,"column_start":44,"column_end":54,"is_primary":true,"text":[{"text":"use crate::basis::reader::{read_basis_set, BasisShell};","highlight_start":44,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/system/basis_loader.rs","byte_start":220,"byte_end":232,"line_start":6,"line_end":6,"column_start":42,"column_end":54,"is_primary":true,"text":[{"text":"use crate::basis::reader::{read_basis_set, BasisShell};","highlight_start":42,"highlight_end":54}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/system/basis_loader.rs","byte_start":205,"byte_end":206,"line_start":6,"line_end":6,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"use crate::basis::reader::{read_basis_set, BasisShell};","highlight_start":27,"highlight_end":28}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/system/basis_loader.rs","byte_start":232,"byte_end":233,"line_start":6,"line_end":6,"column_start":54,"column_end":55,"is_primary":true,"text":[{"text":"use crate::basis::reader::{read_basis_set, BasisShell};","highlight_start":54,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `BasisShell`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/system/basis_loader.rs:6:44\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::basis::reader::{read_basis_set, BasisShell};\n  \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::collections::HashMap`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/system/periodic_table.rs","byte_start":34,"byte_end":59,"line_start":3,"line_end":3,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/system/periodic_table.rs","byte_start":30,"byte_end":61,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::collections::HashMap`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/system/periodic_table.rs:3:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::collections::HashMap;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::collections::HashMap`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/basis/reader.rs","byte_start":52,"byte_end":77,"line_start":3,"line_end":3,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/basis/reader.rs","byte_start":48,"byte_end":79,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `std::collections::HashMap`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/basis/reader.rs:3:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use std::collections::HashMap;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::basis::shell::Shell`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/integrals/eri/eri.rs","byte_start":86,"byte_end":112,"line_start":3,"line_end":3,"column_start":5,"column_end":31,"is_primary":true,"text":[{"text":"use crate::basis::shell::Shell;","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/integrals/eri/eri.rs","byte_start":82,"byte_end":114,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::basis::shell::Shell;","highlight_start":1,"highlight_end":32},{"text":"use crate::system::atom::Atom;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::basis::shell::Shell`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/eri/eri.rs:3:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::basis::shell::Shell;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused doc comment","code":{"code":"unused_doc_comments","explanation":null},"level":"warning","spans":[{"file_name":"src/integrals/eri/eri.rs","byte_start":2256,"byte_end":2278,"line_start":86,"line_end":86,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        let c = atom.position;","highlight_start":9,"highlight_end":31}],"label":"rustdoc does not generate documentation for statements","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/integrals/eri/eri.rs","byte_start":2211,"byte_end":2247,"line_start":85,"line_end":85,"column_start":9,"column_end":45,"is_primary":true,"text":[{"text":"        ///let c = [atom.x, atom.y, atom.z];","highlight_start":9,"highlight_end":45}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use `//` for a plain comment","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused doc comment\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/eri/eri.rs:85:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         ///let c = [atom.x, atom.y, atom.z];\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let c = atom.position;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mrustdoc does not generate documentation for statements\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: use `//` for a plain comment\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::integrals::eri::eri_hrr::hrr_ab`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/integrals/eri/eri_contracted.rs","byte_start":244,"byte_end":282,"line_start":7,"line_end":7,"column_start":5,"column_end":43,"is_primary":true,"text":[{"text":"use crate::integrals::eri::eri_hrr::hrr_ab;","highlight_start":5,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/integrals/eri/eri_contracted.rs","byte_start":240,"byte_end":284,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::integrals::eri::eri_hrr::hrr_ab;","highlight_start":1,"highlight_end":44},{"text":"use crate::integrals::schwarz::schwarz_shell_pair;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::integrals::eri::eri_hrr::hrr_ab`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/eri/eri_contracted.rs:7:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::integrals::eri::eri_hrr::hrr_ab;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `DVector`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/scf/utils.rs","byte_start":203,"byte_end":210,"line_start":10,"line_end":10,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector, SymmetricEigen};","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/scf/utils.rs","byte_start":201,"byte_end":210,"line_start":10,"line_end":10,"column_start":23,"column_end":32,"is_primary":true,"text":[{"text":"use nalgebra::{DMatrix, DVector, SymmetricEigen};","highlight_start":23,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `DVector`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:10:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use nalgebra::{DMatrix, DVector, SymmetricEigen};\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::gradients::overlap::overlap_derivative`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/gradients/fock.rs","byte_start":288,"byte_end":333,"line_start":12,"line_end":12,"column_start":5,"column_end":50,"is_primary":true,"text":[{"text":"use crate::gradients::overlap::overlap_derivative;","highlight_start":5,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/gradients/fock.rs","byte_start":284,"byte_end":335,"line_start":12,"line_end":13,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::gradients::overlap::overlap_derivative;","highlight_start":1,"highlight_end":51},{"text":"use crate::dft::vxc::build_vxc;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::gradients::overlap::overlap_derivative`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:12:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::gradients::overlap::overlap_derivative;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::dft::vxc::build_vxc`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/gradients/fock.rs","byte_start":339,"byte_end":365,"line_start":13,"line_end":13,"column_start":5,"column_end":31,"is_primary":true,"text":[{"text":"use crate::dft::vxc::build_vxc;","highlight_start":5,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/gradients/fock.rs","byte_start":335,"byte_end":367,"line_start":13,"line_end":14,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::dft::vxc::build_vxc;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::dft::vxc::build_vxc`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:13:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::dft::vxc::build_vxc;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::mo::space::MoSpace`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/mo/transform.rs","byte_start":220,"byte_end":245,"line_start":10,"line_end":10,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use crate::mo::space::MoSpace;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/mo/transform.rs","byte_start":216,"byte_end":247,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::mo::space::MoSpace;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::mo::space::MoSpace`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mo/transform.rs:10:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::mo::space::MoSpace;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function is expected to take 4 arguments, but it takes 2 arguments","code":{"code":"E0593","explanation":"You tried to supply an `Fn`-based type with an incorrect number of arguments\nthan what was expected.\n\nErroneous code example:\n\n```compile_fail,E0593\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    // [E0593] closure takes 1 argument but 0 arguments are required\n    foo(|y| { });\n}\n```\n\nYou have to provide the same number of arguments as expected by the `Fn`-based\ntype. So to fix the previous example, we need to remove the `y` argument:\n\n```\nfn foo<F: Fn()>(x: F) { }\n\nfn main() {\n    foo(|| { }); // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1018,"byte_end":1037,"line_start":32,"line_end":32,"column_start":49,"column_end":68,"is_primary":true,"text":[{"text":"    let t = build_matrix(shells, shell_centers, kinetic_shell_shell);","highlight_start":49,"highlight_end":68}],"label":"expected function that takes 4 arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/integrals/kinetic.rs","byte_start":1740,"byte_end":1828,"line_start":75,"line_end":78,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub fn kinetic_shell_shell(","highlight_start":1,"highlight_end":28},{"text":"    shell_a: &Shell,","highlight_start":1,"highlight_end":21},{"text":"    shell_b: &Shell,","highlight_start":1,"highlight_end":21},{"text":") -> Vec<Vec<f64>> {","highlight_start":1,"highlight_end":19}],"label":"takes 2 arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":982,"byte_end":994,"line_start":32,"line_end":32,"column_start":13,"column_end":25,"is_primary":false,"text":[{"text":"    let t = build_matrix(shells, shell_centers, kinetic_shell_shell);","highlight_start":13,"highlight_end":25}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `build_matrix`","code":null,"level":"note","spans":[{"file_name":"src/scf/guess.rs","byte_start":1154,"byte_end":1166,"line_start":37,"line_end":37,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"pub fn build_matrix<F>(","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":1266,"byte_end":1321,"line_start":43,"line_end":43,"column_start":8,"column_end":63,"is_primary":true,"text":[{"text":"    F: Fn(&Shell, [f64; 3], &Shell, [f64; 3]) -> Vec<Vec<f64>>,","highlight_start":8,"highlight_end":63}],"label":"required by this bound in `build_matrix`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0593]\u001b[0m\u001b[1m: function is expected to take 4 arguments, but it takes 2 arguments\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:32:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let t = build_matrix(shells, shell_centers, kinetic_shell_shell);\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94m------------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected function that takes 4 arguments\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/integrals/kinetic.rs:75:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub fn kinetic_shell_shell(\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shell_a: &Shell,\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shell_b: &Shell,\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m ) -> Vec<Vec<f64>> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|__________________-\u001b[0m \u001b[1m\u001b[94mtakes 2 arguments\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `build_matrix`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:43:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_matrix<F>(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     F: Fn(&Shell, [f64; 3], &Shell, [f64; 3]) -> Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `build_matrix`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1147,"byte_end":1149,"line_start":34,"line_end":34,"column_start":43,"column_end":45,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":43,"highlight_end":45}],"label":"unexpected argument #2 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1154,"byte_end":1156,"line_start":34,"line_end":34,"column_start":50,"column_end":52,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":50,"highlight_end":52}],"label":"unexpected argument #4 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1113,"byte_end":1143,"line_start":34,"line_end":34,"column_start":9,"column_end":39,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":9,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/integrals/nuclear_attraction.rs","byte_start":1888,"byte_end":1918,"line_start":85,"line_end":85,"column_start":8,"column_end":38,"is_primary":true,"text":[{"text":"pub fn nuclear_attraction_shell_shell(","highlight_start":8,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1145,"byte_end":1149,"line_start":34,"line_end":34,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":41,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1152,"byte_end":1156,"line_start":34,"line_end":34,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:34:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         nuclear_attraction_shell_shell(a, ca, b, cb, atoms)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m    \u001b[1m\u001b[94m--\u001b[0m     \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94munexpected argument #2 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/nuclear_attraction.rs:85:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn nuclear_attraction_shell_shell(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[91m- \u001b[0m        nuclear_attraction_shell_shell(a\u001b[91m, ca\u001b[0m, b\u001b[91m, cb\u001b[0m, atoms)\n\u001b[1m\u001b[94m34\u001b[0m \u001b[92m+ \u001b[0m        nuclear_attraction_shell_shell(a, b, atoms)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1189,"byte_end":1192,"line_start":36,"line_end":36,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"    let hcore = add(&t, &v);","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1193,"byte_end":1195,"line_start":36,"line_end":36,"column_start":21,"column_end":23,"is_primary":true,"text":[{"text":"    let hcore = add(&t, &v);","highlight_start":21,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1197,"byte_end":1199,"line_start":36,"line_end":36,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"    let hcore = add(&t, &v);","highlight_start":25,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":446,"byte_end":462,"line_start":19,"line_end":19,"column_start":12,"column_end":28,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":12,"highlight_end":28}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":464,"byte_end":480,"line_start":19,"line_end":19,"column_start":30,"column_end":46,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":30,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":442,"byte_end":445,"line_start":19,"line_end":19,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:36:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let hcore = add(&t, &v);\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:36:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let hcore = add(&t, &v);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:36:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let hcore = add(&t, &v);\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:19:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m  \u001b[1m\u001b[94m----------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1571,"byte_end":1574,"line_start":51,"line_end":51,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":21,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1575,"byte_end":1583,"line_start":51,"line_end":51,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":25,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1585,"byte_end":1592,"line_start":51,"line_end":51,"column_start":35,"column_end":42,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":35,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":446,"byte_end":462,"line_start":19,"line_end":19,"column_start":12,"column_end":28,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":12,"highlight_end":28}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":464,"byte_end":480,"line_start":19,"line_end":19,"column_start":30,"column_end":46,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":30,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":442,"byte_end":445,"line_start":19,"line_end":19,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:51:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:51:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:51:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:19:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m  \u001b[1m\u001b[94m----------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1683,"byte_end":1689,"line_start":54,"line_end":54,"column_start":54,"column_end":60,"is_primary":true,"text":[{"text":"        let (j, _) = build_jk(shells, shell_centers, &p_tot);","highlight_start":54,"highlight_end":60}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1651,"byte_end":1659,"line_start":54,"line_end":54,"column_start":22,"column_end":30,"is_primary":false,"text":[{"text":"        let (j, _) = build_jk(shells, shell_centers, &p_tot);","highlight_start":22,"highlight_end":30}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/jk.rs","byte_start":393,"byte_end":416,"line_start":14,"line_end":14,"column_start":5,"column_end":28,"is_primary":false,"text":[{"text":"    density: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":28}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/jk.rs","byte_start":325,"byte_end":333,"line_start":11,"line_end":11,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn build_jk(","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:54:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (j, _) = build_jk(shells, shell_centers, &p_tot);\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m--------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/jk.rs:11:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_jk(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `build_fock` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/scf/jk.rs","byte_start":318,"byte_end":2601,"line_start":11,"line_end":84,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"pub fn build_jk(","highlight_start":1,"highlight_end":17},{"text":"    shells: &[Shell],","highlight_start":1,"highlight_end":22},{"text":"    shell_centers: &[[f64; 3]],","highlight_start":1,"highlight_end":32},{"text":"    density: &Vec<Vec<f64>>,","highlight_start":1,"highlight_end":29},{"text":") -> (Vec<Vec<f64>>, Vec<Vec<f64>>) {","highlight_start":1,"highlight_end":38},{"text":"    let nao = density.len();","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut j = vec![vec![0.0; nao]; nao];","highlight_start":1,"highlight_end":43},{"text":"    let mut k = vec![vec![0.0; nao]; nao];","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // AO index offset per shell","highlight_start":1,"highlight_end":33},{"text":"    let mut shell_offsets = Vec::new();","highlight_start":1,"highlight_end":40},{"text":"    let mut offset = 0;","highlight_start":1,"highlight_end":24},{"text":"    for sh in shells {","highlight_start":1,"highlight_end":23},{"text":"        shell_offsets.push(offset);","highlight_start":1,"highlight_end":36},{"text":"        offset += sh.n_orbitals();","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let nshells = shells.len();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Loop over shell quartets","highlight_start":1,"highlight_end":32},{"text":"    for a in 0..nshells {","highlight_start":1,"highlight_end":26},{"text":"        for b in 0..nshells {","highlight_start":1,"highlight_end":30},{"text":"            for c in 0..nshells {","highlight_start":1,"highlight_end":34},{"text":"                for d in 0..nshells {","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let eri_block = eri_shell_shell_shell_shell(","highlight_start":1,"highlight_end":65},{"text":"                        &shells[a],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[b],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[c],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[d],","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let na = shells[a].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nb = shells[b].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nc = shells[c].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nd = shells[d].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let oa = shell_offsets[a];","highlight_start":1,"highlight_end":47},{"text":"                    let ob = shell_offsets[b];","highlight_start":1,"highlight_end":47},{"text":"                    let oc = shell_offsets[c];","highlight_start":1,"highlight_end":47},{"text":"                    let od = shell_offsets[d];","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let idx = |i, j, k, l| ((i * nb + j) * nc + k) * nd + l;","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    for ia in 0..na {","highlight_start":1,"highlight_end":38},{"text":"                        for ib in 0..nb {","highlight_start":1,"highlight_end":42},{"text":"                            let mu = oa + ia;","highlight_start":1,"highlight_end":46},{"text":"                            let nu = ob + ib;","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            for ic in 0..nc {","highlight_start":1,"highlight_end":46},{"text":"                                for id in 0..nd {","highlight_start":1,"highlight_end":50},{"text":"                                    let lam = oc + ic;","highlight_start":1,"highlight_end":55},{"text":"                                    let sig = od + id;","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    let eri = eri_block[idx(ia, ib, ic, id)];","highlight_start":1,"highlight_end":78},{"text":"                                    let p = density[lam][sig];","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    // Coulomb","highlight_start":1,"highlight_end":47},{"text":"                                    j[mu][nu] += p * eri;","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    // Exchange","highlight_start":1,"highlight_end":48},{"text":"                                    k[mu][lam] += density[nu][sig] * eri;","highlight_start":1,"highlight_end":74},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    (j, k)","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"similarly named function `build_jk` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1879,"byte_end":1889,"line_start":59,"line_end":59,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        let f_alpha = build_fock(&hcore, &j, &k_alpha);","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1879,"byte_end":1889,"line_start":59,"line_end":59,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        let f_alpha = build_fock(&hcore, &j, &k_alpha);","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"build_jk","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `build_fock` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:59:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           let f_alpha = build_fock(&hcore, &j, &k_alpha);\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `build_jk`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/scf/jk.rs:11:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub fn build_jk(\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shells: &[Shell],\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shell_centers: &[[f64; 3]],\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &Vec<Vec<f64>>,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (j, k)\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94msimilarly named function `build_jk` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `build_fock` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/scf/jk.rs","byte_start":318,"byte_end":2601,"line_start":11,"line_end":84,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"pub fn build_jk(","highlight_start":1,"highlight_end":17},{"text":"    shells: &[Shell],","highlight_start":1,"highlight_end":22},{"text":"    shell_centers: &[[f64; 3]],","highlight_start":1,"highlight_end":32},{"text":"    density: &Vec<Vec<f64>>,","highlight_start":1,"highlight_end":29},{"text":") -> (Vec<Vec<f64>>, Vec<Vec<f64>>) {","highlight_start":1,"highlight_end":38},{"text":"    let nao = density.len();","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut j = vec![vec![0.0; nao]; nao];","highlight_start":1,"highlight_end":43},{"text":"    let mut k = vec![vec![0.0; nao]; nao];","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // AO index offset per shell","highlight_start":1,"highlight_end":33},{"text":"    let mut shell_offsets = Vec::new();","highlight_start":1,"highlight_end":40},{"text":"    let mut offset = 0;","highlight_start":1,"highlight_end":24},{"text":"    for sh in shells {","highlight_start":1,"highlight_end":23},{"text":"        shell_offsets.push(offset);","highlight_start":1,"highlight_end":36},{"text":"        offset += sh.n_orbitals();","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let nshells = shells.len();","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Loop over shell quartets","highlight_start":1,"highlight_end":32},{"text":"    for a in 0..nshells {","highlight_start":1,"highlight_end":26},{"text":"        for b in 0..nshells {","highlight_start":1,"highlight_end":30},{"text":"            for c in 0..nshells {","highlight_start":1,"highlight_end":34},{"text":"                for d in 0..nshells {","highlight_start":1,"highlight_end":38},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let eri_block = eri_shell_shell_shell_shell(","highlight_start":1,"highlight_end":65},{"text":"                        &shells[a],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[b],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[c],","highlight_start":1,"highlight_end":36},{"text":"                        &shells[d],","highlight_start":1,"highlight_end":36},{"text":"                    );","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let na = shells[a].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nb = shells[b].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nc = shells[c].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"                    let nd = shells[d].n_orbitals();","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let oa = shell_offsets[a];","highlight_start":1,"highlight_end":47},{"text":"                    let ob = shell_offsets[b];","highlight_start":1,"highlight_end":47},{"text":"                    let oc = shell_offsets[c];","highlight_start":1,"highlight_end":47},{"text":"                    let od = shell_offsets[d];","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    let idx = |i, j, k, l| ((i * nb + j) * nc + k) * nd + l;","highlight_start":1,"highlight_end":77},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    for ia in 0..na {","highlight_start":1,"highlight_end":38},{"text":"                        for ib in 0..nb {","highlight_start":1,"highlight_end":42},{"text":"                            let mu = oa + ia;","highlight_start":1,"highlight_end":46},{"text":"                            let nu = ob + ib;","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            for ic in 0..nc {","highlight_start":1,"highlight_end":46},{"text":"                                for id in 0..nd {","highlight_start":1,"highlight_end":50},{"text":"                                    let lam = oc + ic;","highlight_start":1,"highlight_end":55},{"text":"                                    let sig = od + id;","highlight_start":1,"highlight_end":55},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    let eri = eri_block[idx(ia, ib, ic, id)];","highlight_start":1,"highlight_end":78},{"text":"                                    let p = density[lam][sig];","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    // Coulomb","highlight_start":1,"highlight_end":47},{"text":"                                    j[mu][nu] += p * eri;","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                                    // Exchange","highlight_start":1,"highlight_end":48},{"text":"                                    k[mu][lam] += density[nu][sig] * eri;","highlight_start":1,"highlight_end":74},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    (j, k)","highlight_start":1,"highlight_end":11},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"similarly named function `build_jk` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":1935,"byte_end":1945,"line_start":60,"line_end":60,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        let f_beta  = build_fock(&hcore, &j, &k_beta);","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/scf/uhf.rs","byte_start":1935,"byte_end":1945,"line_start":60,"line_end":60,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        let f_beta  = build_fock(&hcore, &j, &k_beta);","highlight_start":23,"highlight_end":33}],"label":null,"suggested_replacement":"build_jk","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `build_fock` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:60:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           let f_beta  = build_fock(&hcore, &j, &k_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `build_jk`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/scf/jk.rs:11:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m pub fn build_jk(\n\u001b[1m\u001b[94m12\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shells: &[Shell],\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shell_centers: &[[f64; 3]],\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &Vec<Vec<f64>>,\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     (j, k)\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m }\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_-\u001b[0m \u001b[1m\u001b[94msimilarly named function `build_jk` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2012,"byte_end":2022,"line_start":63,"line_end":63,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"        let err_a = diis_error(&f_alpha, &p_alpha, &s);","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2033,"byte_end":2041,"line_start":63,"line_end":63,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"        let err_a = diis_error(&f_alpha, &p_alpha, &s);","highlight_start":42,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2043,"byte_end":2045,"line_start":63,"line_end":63,"column_start":52,"column_end":54,"is_primary":true,"text":[{"text":"        let err_a = diis_error(&f_alpha, &p_alpha, &s);","highlight_start":52,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":3634,"byte_end":3656,"line_start":143,"line_end":143,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3662,"byte_end":3684,"line_start":144,"line_end":144,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    overlap: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3593,"byte_end":3603,"line_start":141,"line_end":141,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"pub fn diis_error(","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:63:21\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_a = diis_error(&f_alpha, &p_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:63:42\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_a = diis_error(&f_alpha, &p_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:63:52\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_a = diis_error(&f_alpha, &p_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[92m^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:141:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn diis_error(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     overlap: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2068,"byte_end":2078,"line_start":64,"line_end":64,"column_start":21,"column_end":31,"is_primary":true,"text":[{"text":"        let err_b = diis_error(&f_beta, &p_beta, &s);","highlight_start":21,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2088,"byte_end":2095,"line_start":64,"line_end":64,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"        let err_b = diis_error(&f_beta, &p_beta, &s);","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2097,"byte_end":2099,"line_start":64,"line_end":64,"column_start":50,"column_end":52,"is_primary":true,"text":[{"text":"        let err_b = diis_error(&f_beta, &p_beta, &s);","highlight_start":50,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":3634,"byte_end":3656,"line_start":143,"line_end":143,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3662,"byte_end":3684,"line_start":144,"line_end":144,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    overlap: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3593,"byte_end":3603,"line_start":141,"line_end":141,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"pub fn diis_error(","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:64:21\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_b = diis_error(&f_beta, &p_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:64:41\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_b = diis_error(&f_beta, &p_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:64:50\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_b = diis_error(&f_beta, &p_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[92m^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:141:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn diis_error(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     overlap: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2140,"byte_end":2145,"line_start":66,"line_end":66,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"        diis_a.push(f_alpha.clone(), err_a);","highlight_start":38,"highlight_end":43}],"label":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":2118,"byte_end":2122,"line_start":66,"line_end":66,"column_start":16,"column_end":20,"is_primary":false,"text":[{"text":"        diis_a.push(f_alpha.clone(), err_a);","highlight_start":16,"highlight_end":20}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/diis.rs","byte_start":511,"byte_end":531,"line_start":21,"line_end":21,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":49,"highlight_end":69}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":474,"byte_end":478,"line_start":21,"line_end":21,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:66:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_a.push(f_alpha.clone(), err_a);\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94m----\u001b[0m                  \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/diis.rs:21:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m                                 \u001b[1m\u001b[94m--------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2184,"byte_end":2189,"line_start":67,"line_end":67,"column_start":37,"column_end":42,"is_primary":true,"text":[{"text":"        diis_b.push(f_beta.clone(), err_b);","highlight_start":37,"highlight_end":42}],"label":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":2163,"byte_end":2167,"line_start":67,"line_end":67,"column_start":16,"column_end":20,"is_primary":false,"text":[{"text":"        diis_b.push(f_beta.clone(), err_b);","highlight_start":16,"highlight_end":20}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/diis.rs","byte_start":511,"byte_end":531,"line_start":21,"line_end":21,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":49,"highlight_end":69}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":474,"byte_end":478,"line_start":21,"line_end":21,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:67:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_b.push(f_beta.clone(), err_b);\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94m----\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/diis.rs:21:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m                                 \u001b[1m\u001b[94m--------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2368,"byte_end":2382,"line_start":73,"line_end":73,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"        let (c_a, _) = solve_roothaan(&f_alpha, &s);","highlight_start":24,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2383,"byte_end":2391,"line_start":73,"line_end":73,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        let (c_a, _) = solve_roothaan(&f_alpha, &s);","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2393,"byte_end":2395,"line_start":73,"line_end":73,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"        let (c_a, _) = solve_roothaan(&f_alpha, &s);","highlight_start":49,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2794,"byte_end":2813,"line_start":113,"line_end":113,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2819,"byte_end":2841,"line_start":114,"line_end":114,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    overlap: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2774,"byte_end":2788,"line_start":112,"line_end":112,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn solve_roothaan(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:73:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_a, _) = solve_roothaan(&f_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:73:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_a, _) = solve_roothaan(&f_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:73:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_a, _) = solve_roothaan(&f_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn solve_roothaan(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     overlap: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2421,"byte_end":2435,"line_start":74,"line_end":74,"column_start":24,"column_end":38,"is_primary":true,"text":[{"text":"        let (c_b, _) = solve_roothaan(&f_beta, &s);","highlight_start":24,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2436,"byte_end":2443,"line_start":74,"line_end":74,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"        let (c_b, _) = solve_roothaan(&f_beta, &s);","highlight_start":39,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2445,"byte_end":2447,"line_start":74,"line_end":74,"column_start":48,"column_end":50,"is_primary":true,"text":[{"text":"        let (c_b, _) = solve_roothaan(&f_beta, &s);","highlight_start":48,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2794,"byte_end":2813,"line_start":113,"line_end":113,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2819,"byte_end":2841,"line_start":114,"line_end":114,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    overlap: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2774,"byte_end":2788,"line_start":112,"line_end":112,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn solve_roothaan(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:74:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_b, _) = solve_roothaan(&f_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:74:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_b, _) = solve_roothaan(&f_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:74:48\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_b, _) = solve_roothaan(&f_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn solve_roothaan(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     overlap: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2521,"byte_end":2525,"line_start":77,"line_end":77,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"        let p_alpha_new = build_spin_density(&c_a, n_alpha);","highlight_start":46,"highlight_end":50}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":2502,"byte_end":2520,"line_start":77,"line_end":77,"column_start":27,"column_end":45,"is_primary":false,"text":[{"text":"        let p_alpha_new = build_spin_density(&c_a, n_alpha);","highlight_start":27,"highlight_end":45}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/density.rs","byte_start":824,"byte_end":845,"line_start":39,"line_end":39,"column_start":5,"column_end":26,"is_primary":false,"text":[{"text":"    coeff: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":26}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/density.rs","byte_start":800,"byte_end":818,"line_start":38,"line_end":38,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"pub fn build_spin_density(","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:77:46\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_alpha_new = build_spin_density(&c_a, n_alpha);\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/density.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_spin_density(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2582,"byte_end":2586,"line_start":78,"line_end":78,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"        let p_beta_new  = build_spin_density(&c_b, n_beta);","highlight_start":46,"highlight_end":50}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/uhf.rs","byte_start":2563,"byte_end":2581,"line_start":78,"line_end":78,"column_start":27,"column_end":45,"is_primary":false,"text":[{"text":"        let p_beta_new  = build_spin_density(&c_b, n_beta);","highlight_start":27,"highlight_end":45}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/density.rs","byte_start":824,"byte_end":845,"line_start":39,"line_end":39,"column_start":5,"column_end":26,"is_primary":false,"text":[{"text":"    coeff: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":26}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/density.rs","byte_start":800,"byte_end":818,"line_start":38,"line_end":38,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"pub fn build_spin_density(","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:78:46\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_beta_new  = build_spin_density(&c_b, n_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/density.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_spin_density(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `uhf_energy` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2632,"byte_end":2642,"line_start":81,"line_end":81,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"        let e = uhf_energy(&p_alpha_new, &p_beta_new, &hcore, &j, &k_alpha, &k_beta);","highlight_start":17,"highlight_end":27}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `uhf_energy` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:81:17\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let e = uhf_energy(&p_alpha_new, &p_beta_new, &hcore, &j, &k_alpha, &k_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `rms_diff` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2756,"byte_end":2764,"line_start":84,"line_end":84,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"        let dP = rms_diff(&p_alpha, &p_alpha_new)","highlight_start":18,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `rms_diff` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:84:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dP = rms_diff(&p_alpha, &p_alpha_new)\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `rms_diff` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/scf/uhf.rs","byte_start":2806,"byte_end":2814,"line_start":85,"line_end":85,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"               + rms_diff(&p_beta,  &p_beta_new);","highlight_start":18,"highlight_end":26}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `rms_diff` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/uhf.rs:85:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                + rms_diff(&p_beta,  &p_beta_new);\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":822,"byte_end":830,"line_start":26,"line_end":26,"column_start":46,"column_end":54,"is_primary":true,"text":[{"text":"    let nao: usize = shells.iter().map(|s| s.orbitals.len()).sum();","highlight_start":46,"highlight_end":54}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:26:46\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let nao: usize = shells.iter().map(|s| s.orbitals.len()).sum();\n   \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":927,"byte_end":946,"line_start":29,"line_end":29,"column_start":62,"column_end":81,"is_primary":true,"text":[{"text":"    let s = build_one_electron_matrix(shells, shell_centers, overlap_shell_shell);","highlight_start":62,"highlight_end":81}],"label":"expected `&[Atom]`, found fn item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":878,"byte_end":903,"line_start":29,"line_end":29,"column_start":13,"column_end":38,"is_primary":false,"text":[{"text":"    let s = build_one_electron_matrix(shells, shell_centers, overlap_shell_shell);","highlight_start":13,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&[Atom]`\n     found fn item `for<'a, 'b> fn(&'a Shell, &'b Shell) -> Vec<Vec<f64>> {overlap_contracted::overlap_shell_shell}`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":850,"byte_end":864,"line_start":35,"line_end":35,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    atoms: &[Atom],","highlight_start":5,"highlight_end":19}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":765,"byte_end":790,"line_start":32,"line_end":32,"column_start":8,"column_end":33,"is_primary":true,"text":[{"text":"pub fn build_one_electron_matrix(","highlight_start":8,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:29:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let s = build_one_electron_matrix(shells, shell_centers, overlap_shell_shell);\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-------------------------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&[Atom]`, found fn item\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `\u001b[1m\u001b[35m&[Atom]\u001b[0m`\n                found fn item `\u001b[1m\u001b[35mfor<'a, 'b> fn(&'a Shell, &'b Shell) -> Vec<Vec<f64>> {overlap_contracted::overlap_shell_shell}\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:32:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_one_electron_matrix(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atoms: &[Atom],\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1010,"byte_end":1029,"line_start":30,"line_end":30,"column_start":62,"column_end":81,"is_primary":true,"text":[{"text":"    let t = build_one_electron_matrix(shells, shell_centers, kinetic_shell_shell);","highlight_start":62,"highlight_end":81}],"label":"expected `&[Atom]`, found fn item","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":961,"byte_end":986,"line_start":30,"line_end":30,"column_start":13,"column_end":38,"is_primary":false,"text":[{"text":"    let t = build_one_electron_matrix(shells, shell_centers, kinetic_shell_shell);","highlight_start":13,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&[Atom]`\n     found fn item `for<'a, 'b> fn(&'a Shell, &'b Shell) -> Vec<Vec<f64>> {kinetic_shell_shell}`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":850,"byte_end":864,"line_start":35,"line_end":35,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    atoms: &[Atom],","highlight_start":5,"highlight_end":19}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":765,"byte_end":790,"line_start":32,"line_end":32,"column_start":8,"column_end":33,"is_primary":true,"text":[{"text":"pub fn build_one_electron_matrix(","highlight_start":8,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:30:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let t = build_one_electron_matrix(shells, shell_centers, kinetic_shell_shell);\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-------------------------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&[Atom]`, found fn item\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `\u001b[1m\u001b[35m&[Atom]\u001b[0m`\n                found fn item `\u001b[1m\u001b[35mfor<'a, 'b> fn(&'a Shell, &'b Shell) -> Vec<Vec<f64>> {kinetic_shell_shell}\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:32:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_one_electron_matrix(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atoms: &[Atom],\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1159,"byte_end":1161,"line_start":32,"line_end":32,"column_start":50,"column_end":52,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":50,"highlight_end":52}],"label":"unexpected argument #4","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1163,"byte_end":1168,"line_start":32,"line_end":32,"column_start":54,"column_end":59,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":54,"highlight_end":59}],"label":"unexpected argument #5 of type `&[Atom]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1118,"byte_end":1148,"line_start":32,"line_end":32,"column_start":9,"column_end":39,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":9,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/integrals/nuclear_attraction.rs","byte_start":1888,"byte_end":1918,"line_start":85,"line_end":85,"column_start":8,"column_end":38,"is_primary":true,"text":[{"text":"pub fn nuclear_attraction_shell_shell(","highlight_start":8,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":1157,"byte_end":1161,"line_start":32,"line_end":32,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1161,"byte_end":1168,"line_start":32,"line_end":32,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":52,"highlight_end":59}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:32:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         nuclear_attraction_shell_shell(a, ca, b, cb, atoms)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m           \u001b[1m\u001b[94m--\u001b[0m  \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94munexpected argument #5 of type `&[Atom]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94munexpected argument #4\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/nuclear_attraction.rs:85:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn nuclear_attraction_shell_shell(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[91m- \u001b[0m        nuclear_attraction_shell_shell(a, ca, b\u001b[91m, cb, atoms\u001b[0m)\n\u001b[1m\u001b[94m32\u001b[0m \u001b[92m+ \u001b[0m        nuclear_attraction_shell_shell(a, ca, b)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1093,"byte_end":1175,"line_start":31,"line_end":33,"column_start":62,"column_end":6,"is_primary":true,"text":[{"text":"    let v = build_one_electron_matrix(shells, shell_centers, |a, ca, b, cb| {","highlight_start":62,"highlight_end":78},{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":1,"highlight_end":60},{"text":"    });","highlight_start":1,"highlight_end":6}],"label":"expected `&[Atom]`, found closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1044,"byte_end":1069,"line_start":31,"line_end":31,"column_start":13,"column_end":38,"is_primary":false,"text":[{"text":"    let v = build_one_electron_matrix(shells, shell_centers, |a, ca, b, cb| {","highlight_start":13,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&[Atom]`\n     found closure `{closure@src/scf/udft.rs:31:62: 31:76}`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":850,"byte_end":864,"line_start":35,"line_end":35,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    atoms: &[Atom],","highlight_start":5,"highlight_end":19}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":765,"byte_end":790,"line_start":32,"line_end":32,"column_start":8,"column_end":33,"is_primary":true,"text":[{"text":"pub fn build_one_electron_matrix(","highlight_start":8,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:31:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let v = build_one_electron_matrix(shells, shell_centers, |a, ca, b, cb| {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _____________\u001b[0m\u001b[1m\u001b[94m-------------------------\u001b[0m\u001b[1m\u001b[91m________________________^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         nuclear_attraction_shell_shell(a, ca, b, cb, atoms)\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     });\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mexpected `&[Atom]`, found closure\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `\u001b[1m\u001b[35m&[Atom]\u001b[0m`\n                found closure `\u001b[1m\u001b[35m{closure@src/scf/udft.rs:31:62: 31:76}\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:32:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_one_electron_matrix(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atoms: &[Atom],\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1663,"byte_end":1666,"line_start":53,"line_end":53,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":21,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":1667,"byte_end":1675,"line_start":53,"line_end":53,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":25,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":1677,"byte_end":1684,"line_start":53,"line_end":53,"column_start":35,"column_end":42,"is_primary":true,"text":[{"text":"        let p_tot = add(&p_alpha, &p_beta);","highlight_start":35,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":446,"byte_end":462,"line_start":19,"line_end":19,"column_start":12,"column_end":28,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":12,"highlight_end":28}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":464,"byte_end":480,"line_start":19,"line_end":19,"column_start":30,"column_end":46,"is_primary":false,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":30,"highlight_end":46}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":442,"byte_end":445,"line_start":19,"line_end":19,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:53:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:53:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:53:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_tot = add(&p_alpha, &p_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:19:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn add(a: &DMatrix<f64>, b: &DMatrix<f64>) -> DMatrix<f64> {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m  \u001b[1m\u001b[94m----------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1741,"byte_end":1747,"line_start":55,"line_end":55,"column_start":54,"column_end":60,"is_primary":true,"text":[{"text":"        let (j, _) = build_jk(shells, shell_centers, &p_tot);","highlight_start":54,"highlight_end":60}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1709,"byte_end":1717,"line_start":55,"line_end":55,"column_start":22,"column_end":30,"is_primary":false,"text":[{"text":"        let (j, _) = build_jk(shells, shell_centers, &p_tot);","highlight_start":22,"highlight_end":30}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/jk.rs","byte_start":393,"byte_end":416,"line_start":14,"line_end":14,"column_start":5,"column_end":28,"is_primary":false,"text":[{"text":"    density: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":28}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/jk.rs","byte_start":325,"byte_end":333,"line_start":11,"line_end":11,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn build_jk(","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:55:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (j, _) = build_jk(shells, shell_centers, &p_tot);\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m--------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/jk.rs:11:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_jk(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":1940,"byte_end":1947,"line_start":59,"line_end":59,"column_start":59,"column_end":66,"is_primary":false,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":59,"highlight_end":66}],"label":"unexpected argument #4 of type `f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1904,"byte_end":1921,"line_start":59,"line_end":59,"column_start":23,"column_end":40,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":23,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":1930,"byte_end":1932,"line_start":59,"line_end":59,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":49,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":1934,"byte_end":1938,"line_start":59,"line_end":59,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2044,"byte_end":2060,"line_start":78,"line_end":78,"column_start":5,"column_end":21,"is_primary":false,"text":[{"text":"    j: &DMatrix<f64>,","highlight_start":5,"highlight_end":21}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2066,"byte_end":2082,"line_start":79,"line_end":79,"column_start":5,"column_end":21,"is_primary":false,"text":[{"text":"    k: &DMatrix<f64>,","highlight_start":5,"highlight_end":21}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":1995,"byte_end":2012,"line_start":76,"line_end":76,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"pub fn build_fock_scaled(","highlight_start":8,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":1938,"byte_end":1947,"line_start":59,"line_end":59,"column_start":57,"column_end":66,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":57,"highlight_end":66}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1930,"byte_end":1932,"line_start":59,"line_end":59,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":49,"highlight_end":51}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1934,"byte_end":1938,"line_start":59,"line_end":59,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"        let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 4 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:59:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m                   \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:59:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:59:53\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_a = build_fock_scaled(&hcore, &j, &k_a, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:76:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_fock_scaled(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     hcore: &DMatrix<f64>,\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     j: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     k: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[91m- \u001b[0m        let mut f_a = build_fock_scaled(&hcore, \u001b[91m&j\u001b[0m, \u001b[91m&k_a, hf_frac\u001b[0m);\n\u001b[1m\u001b[94m59\u001b[0m \u001b[92m+ \u001b[0m        let mut f_a = build_fock_scaled(&hcore, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2008,"byte_end":2015,"line_start":60,"line_end":60,"column_start":59,"column_end":66,"is_primary":false,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":59,"highlight_end":66}],"label":"unexpected argument #4 of type `f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1972,"byte_end":1989,"line_start":60,"line_end":60,"column_start":23,"column_end":40,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":23,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":1998,"byte_end":2000,"line_start":60,"line_end":60,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":49,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2002,"byte_end":2006,"line_start":60,"line_end":60,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2044,"byte_end":2060,"line_start":78,"line_end":78,"column_start":5,"column_end":21,"is_primary":false,"text":[{"text":"    j: &DMatrix<f64>,","highlight_start":5,"highlight_end":21}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2066,"byte_end":2082,"line_start":79,"line_end":79,"column_start":5,"column_end":21,"is_primary":false,"text":[{"text":"    k: &DMatrix<f64>,","highlight_start":5,"highlight_end":21}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":1995,"byte_end":2012,"line_start":76,"line_end":76,"column_start":8,"column_end":25,"is_primary":true,"text":[{"text":"pub fn build_fock_scaled(","highlight_start":8,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2006,"byte_end":2015,"line_start":60,"line_end":60,"column_start":57,"column_end":66,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":57,"highlight_end":66}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":1998,"byte_end":2000,"line_start":60,"line_end":60,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":49,"highlight_end":51}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2002,"byte_end":2006,"line_start":60,"line_end":60,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"        let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 4 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:60:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m                   \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:60:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:60:53\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut f_b = build_fock_scaled(&hcore, &j, &k_b, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:76:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_fock_scaled(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     hcore: &DMatrix<f64>,\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     j: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     k: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[91m- \u001b[0m        let mut f_b = build_fock_scaled(&hcore, \u001b[91m&j\u001b[0m, \u001b[91m&k_b, hf_frac\u001b[0m);\n\u001b[1m\u001b[94m60\u001b[0m \u001b[92m+ \u001b[0m        let mut f_b = build_fock_scaled(&hcore, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 10 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2077,"byte_end":2123,"line_start":63,"line_end":63,"column_start":27,"column_end":73,"is_primary":false,"text":[{"text":"            build_vxc_udft(shells, shell_centers, &p_alpha, &p_beta, xc);","highlight_start":27,"highlight_end":73}],"label":"multiple arguments are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2063,"byte_end":2077,"line_start":63,"line_end":63,"column_start":13,"column_end":27,"is_primary":true,"text":[{"text":"            build_vxc_udft(shells, shell_centers, &p_alpha, &p_beta, xc);","highlight_start":13,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/vxc.rs","byte_start":5215,"byte_end":5246,"line_start":198,"line_end":198,"column_start":5,"column_end":36,"is_primary":false,"text":[{"text":"    coeff_a: Option<&Vec<Vec<f64>>>,","highlight_start":5,"highlight_end":36}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":5252,"byte_end":5283,"line_start":199,"line_end":199,"column_start":5,"column_end":36,"is_primary":false,"text":[{"text":"    coeff_b: Option<&Vec<Vec<f64>>>,","highlight_start":5,"highlight_end":36}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":5289,"byte_end":5311,"line_start":200,"line_end":200,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    n_occ_a: Option<usize>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":5317,"byte_end":5339,"line_start":201,"line_end":201,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    n_occ_b: Option<usize>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":5345,"byte_end":5359,"line_start":202,"line_end":202,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    atoms: &[Atom],","highlight_start":5,"highlight_end":19}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":5084,"byte_end":5098,"line_start":193,"line_end":193,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn build_vxc_udft(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2077,"byte_end":2123,"line_start":63,"line_end":63,"column_start":27,"column_end":73,"is_primary":true,"text":[{"text":"            build_vxc_udft(shells, shell_centers, &p_alpha, &p_beta, xc);","highlight_start":27,"highlight_end":73}],"label":null,"suggested_replacement":"(shells, shell_centers, &p_alpha, &p_beta, /* Option<&Vec<Vec<f64>>> */, /* Option<&Vec<Vec<f64>>> */, /* Option<usize> */, /* Option<usize> */, /* &[Atom] */, xc)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 10 arguments but 5 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:63:13\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             build_vxc_udft(shells, shell_centers, &p_alpha, &p_beta, xc);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m----------------------------------------------\u001b[0m \u001b[1m\u001b[94mmultiple arguments are missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:193:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_vxc_udft(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff_a: Option<&Vec<Vec<f64>>>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------------------\u001b[0m\n\u001b[1m\u001b[94m199\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff_b: Option<&Vec<Vec<f64>>>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------------------\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     n_occ_a: Option<usize>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\u001b[1m\u001b[94m201\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     n_occ_b: Option<usize>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\u001b[1m\u001b[94m202\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atoms: &[Atom],\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the arguments\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            build_vxc_udft(shells, shell_centers, &p_alpha, &p_beta, \u001b[92m/* Option<&Vec<Vec<f64>>> */, /* Option<&Vec<Vec<f64>>> */, /* Option<usize> */, /* Option<usize> */, /* &[Atom] */, \u001b[0mxc);\n    \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[92m++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2156,"byte_end":2160,"line_start":65,"line_end":65,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        add_inplace(&mut f_a, &vxa);","highlight_start":31,"highlight_end":35}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2134,"byte_end":2145,"line_start":65,"line_end":65,"column_start":9,"column_end":20,"is_primary":false,"text":[{"text":"        add_inplace(&mut f_a, &vxa);","highlight_start":9,"highlight_end":20}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":554,"byte_end":570,"line_start":23,"line_end":23,"column_start":42,"column_end":58,"is_primary":false,"text":[{"text":"pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {","highlight_start":42,"highlight_end":58}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":520,"byte_end":531,"line_start":23,"line_end":23,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {","highlight_start":8,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:65:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         add_inplace(&mut f_a, &vxa);\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------\u001b[0m           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:23:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m                       \u001b[1m\u001b[94m----------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2193,"byte_end":2197,"line_start":66,"line_end":66,"column_start":31,"column_end":35,"is_primary":true,"text":[{"text":"        add_inplace(&mut f_b, &vxb);","highlight_start":31,"highlight_end":35}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2171,"byte_end":2182,"line_start":66,"line_end":66,"column_start":9,"column_end":20,"is_primary":false,"text":[{"text":"        add_inplace(&mut f_b, &vxb);","highlight_start":9,"highlight_end":20}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":554,"byte_end":570,"line_start":23,"line_end":23,"column_start":42,"column_end":58,"is_primary":false,"text":[{"text":"pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {","highlight_start":42,"highlight_end":58}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":520,"byte_end":531,"line_start":23,"line_end":23,"column_start":8,"column_end":19,"is_primary":true,"text":[{"text":"pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {","highlight_start":8,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:66:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         add_inplace(&mut f_b, &vxb);\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------\u001b[0m           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:23:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn add_inplace(a: &mut DMatrix<f64>, b: &DMatrix<f64>) {\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m                       \u001b[1m\u001b[94m----------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2273,"byte_end":2281,"line_start":70,"line_end":70,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"        let err_a = diis_error(&f_a, &p_alpha, &s);","highlight_start":38,"highlight_end":46}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2256,"byte_end":2266,"line_start":70,"line_end":70,"column_start":21,"column_end":31,"is_primary":false,"text":[{"text":"        let err_a = diis_error(&f_a, &p_alpha, &s);","highlight_start":21,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":3634,"byte_end":3656,"line_start":143,"line_end":143,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3593,"byte_end":3603,"line_start":141,"line_end":141,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"pub fn diis_error(","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:70:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_a = diis_error(&f_a, &p_alpha, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m----------\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:141:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn diis_error(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2325,"byte_end":2332,"line_start":71,"line_end":71,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"        let err_b = diis_error(&f_b, &p_beta, &s);","highlight_start":38,"highlight_end":45}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2308,"byte_end":2318,"line_start":71,"line_end":71,"column_start":21,"column_end":31,"is_primary":false,"text":[{"text":"        let err_b = diis_error(&f_b, &p_beta, &s);","highlight_start":21,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":3634,"byte_end":3656,"line_start":143,"line_end":143,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":3593,"byte_end":3603,"line_start":141,"line_end":141,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"pub fn diis_error(","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:71:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let err_b = diis_error(&f_b, &p_beta, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m----------\u001b[0m       \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:141:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn diis_error(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this method are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2355,"byte_end":2359,"line_start":73,"line_end":73,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        diis_a.push(f_a.clone(), err_a);","highlight_start":16,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2360,"byte_end":2371,"line_start":73,"line_end":73,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"        diis_a.push(f_a.clone(), err_a);","highlight_start":21,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2373,"byte_end":2378,"line_start":73,"line_end":73,"column_start":34,"column_end":39,"is_primary":true,"text":[{"text":"        diis_a.push(f_a.clone(), err_a);","highlight_start":34,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/diis.rs","byte_start":490,"byte_end":509,"line_start":21,"line_end":21,"column_start":28,"column_end":47,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":28,"highlight_end":47}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":511,"byte_end":531,"line_start":21,"line_end":21,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":49,"highlight_end":69}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":474,"byte_end":478,"line_start":21,"line_end":21,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this method are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:73:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_a.push(f_a.clone(), err_a);\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:73:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_a.push(f_a.clone(), err_a);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:73:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_a.push(f_a.clone(), err_a);\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[92m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/diis.rs:21:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m            \u001b[1m\u001b[94m-------------------\u001b[0m  \u001b[1m\u001b[94m--------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this method are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2396,"byte_end":2400,"line_start":74,"line_end":74,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"        diis_b.push(f_b.clone(), err_b);","highlight_start":16,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2401,"byte_end":2412,"line_start":74,"line_end":74,"column_start":21,"column_end":32,"is_primary":true,"text":[{"text":"        diis_b.push(f_b.clone(), err_b);","highlight_start":21,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2414,"byte_end":2419,"line_start":74,"line_end":74,"column_start":34,"column_end":39,"is_primary":true,"text":[{"text":"        diis_b.push(f_b.clone(), err_b);","highlight_start":34,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/diis.rs","byte_start":490,"byte_end":509,"line_start":21,"line_end":21,"column_start":28,"column_end":47,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":28,"highlight_end":47}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":511,"byte_end":531,"line_start":21,"line_end":21,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":49,"highlight_end":69}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/diis.rs","byte_start":474,"byte_end":478,"line_start":21,"line_end":21,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this method are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:74:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_b.push(f_b.clone(), err_b);\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:74:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_b.push(f_b.clone(), err_b);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:74:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         diis_b.push(f_b.clone(), err_b);\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[92m^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/diis.rs:21:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn push(&mut self, fock: Vec<Vec<f64>>, error: Vec<Vec<f64>>) {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^\u001b[0m            \u001b[1m\u001b[94m-------------------\u001b[0m  \u001b[1m\u001b[94m--------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2472,"byte_end":2475,"line_start":76,"line_end":76,"column_start":50,"column_end":53,"is_primary":true,"text":[{"text":"        let f_a = diis_a.extrapolate().unwrap_or(f_a);","highlight_start":50,"highlight_end":53}],"label":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2462,"byte_end":2471,"line_start":76,"line_end":76,"column_start":40,"column_end":49,"is_primary":false,"text":[{"text":"        let f_a = diis_a.extrapolate().unwrap_or(f_a);","highlight_start":40,"highlight_end":49}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the return type of this call is `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2472,"byte_end":2475,"line_start":76,"line_end":76,"column_start":50,"column_end":53,"is_primary":false,"text":[{"text":"        let f_a = diis_a.extrapolate().unwrap_or(f_a);","highlight_start":50,"highlight_end":53}],"label":"this argument influences the return type of `unwrap_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2441,"byte_end":2476,"line_start":76,"line_end":76,"column_start":19,"column_end":54,"is_primary":true,"text":[{"text":"        let f_a = diis_a.extrapolate().unwrap_or(f_a);","highlight_start":19,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/usr/src/debug/rust/rustc-1.92.0-src/library/core/src/option.rs","byte_start":40288,"byte_end":40297,"line_start":1037,"line_end":1037,"column_start":18,"column_end":27,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:76:50\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let f_a = diis_a.extrapolate().unwrap_or(f_a);\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>` due to the type of the argument passed\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:76:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let f_a = diis_a.extrapolate().unwrap_or(f_a);\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94mthis argument influences the return type of `unwrap_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/usr/src/debug/rust/rustc-1.92.0-src/library/core/src/option.rs:1037:18\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2527,"byte_end":2530,"line_start":77,"line_end":77,"column_start":50,"column_end":53,"is_primary":true,"text":[{"text":"        let f_b = diis_b.extrapolate().unwrap_or(f_b);","highlight_start":50,"highlight_end":53}],"label":"expected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2517,"byte_end":2526,"line_start":77,"line_end":77,"column_start":40,"column_end":49,"is_primary":false,"text":[{"text":"        let f_b = diis_b.extrapolate().unwrap_or(f_b);","highlight_start":40,"highlight_end":49}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<Vec<f64>>`\n   found struct `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the return type of this call is `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2527,"byte_end":2530,"line_start":77,"line_end":77,"column_start":50,"column_end":53,"is_primary":false,"text":[{"text":"        let f_b = diis_b.extrapolate().unwrap_or(f_b);","highlight_start":50,"highlight_end":53}],"label":"this argument influences the return type of `unwrap_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2496,"byte_end":2531,"line_start":77,"line_end":77,"column_start":19,"column_end":54,"is_primary":true,"text":[{"text":"        let f_b = diis_b.extrapolate().unwrap_or(f_b);","highlight_start":19,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/usr/src/debug/rust/rustc-1.92.0-src/library/core/src/option.rs","byte_start":40288,"byte_end":40297,"line_start":1037,"line_end":1037,"column_start":18,"column_end":27,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:77:50\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let f_b = diis_b.extrapolate().unwrap_or(f_b);\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<Vec<f64>>`, found `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found struct `\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>` due to the type of the argument passed\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:77:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let f_b = diis_b.extrapolate().unwrap_or(f_b);\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[94mthis argument influences the return type of `unwrap_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[94m--> \u001b[0m/usr/src/debug/rust/rustc-1.92.0-src/library/core/src/option.rs:1037:18\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2572,"byte_end":2576,"line_start":79,"line_end":79,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"        let (c_a, _) = solve_roothaan(&f_a, &s);","highlight_start":39,"highlight_end":43}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2557,"byte_end":2571,"line_start":79,"line_end":79,"column_start":24,"column_end":38,"is_primary":false,"text":[{"text":"        let (c_a, _) = solve_roothaan(&f_a, &s);","highlight_start":24,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2794,"byte_end":2813,"line_start":113,"line_end":113,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2774,"byte_end":2788,"line_start":112,"line_end":112,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn solve_roothaan(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:79:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_a, _) = solve_roothaan(&f_a, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn solve_roothaan(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2621,"byte_end":2625,"line_start":80,"line_end":80,"column_start":39,"column_end":43,"is_primary":true,"text":[{"text":"        let (c_b, _) = solve_roothaan(&f_b, &s);","highlight_start":39,"highlight_end":43}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2606,"byte_end":2620,"line_start":80,"line_end":80,"column_start":24,"column_end":38,"is_primary":false,"text":[{"text":"        let (c_b, _) = solve_roothaan(&f_b, &s);","highlight_start":24,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2794,"byte_end":2813,"line_start":113,"line_end":113,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2774,"byte_end":2788,"line_start":112,"line_end":112,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn solve_roothaan(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:80:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (c_b, _) = solve_roothaan(&f_b, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn solve_roothaan(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2678,"byte_end":2682,"line_start":82,"line_end":82,"column_start":46,"column_end":50,"is_primary":true,"text":[{"text":"        let p_alpha_new = build_spin_density(&c_a, n_alpha);","highlight_start":46,"highlight_end":50}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2659,"byte_end":2677,"line_start":82,"line_end":82,"column_start":27,"column_end":45,"is_primary":false,"text":[{"text":"        let p_alpha_new = build_spin_density(&c_a, n_alpha);","highlight_start":27,"highlight_end":45}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/density.rs","byte_start":824,"byte_end":845,"line_start":39,"line_end":39,"column_start":5,"column_end":26,"is_primary":false,"text":[{"text":"    coeff: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":26}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/density.rs","byte_start":800,"byte_end":818,"line_start":38,"line_end":38,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"pub fn build_spin_density(","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:82:46\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_alpha_new = build_spin_density(&c_a, n_alpha);\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/density.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_spin_density(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2738,"byte_end":2742,"line_start":83,"line_end":83,"column_start":45,"column_end":49,"is_primary":true,"text":[{"text":"        let p_beta_new = build_spin_density(&c_b, n_beta);","highlight_start":45,"highlight_end":49}],"label":"expected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2719,"byte_end":2737,"line_start":83,"line_end":83,"column_start":26,"column_end":44,"is_primary":false,"text":[{"text":"        let p_beta_new = build_spin_density(&c_b, n_beta);","highlight_start":26,"highlight_end":44}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Vec<Vec<f64>>`\n   found reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/density.rs","byte_start":824,"byte_end":845,"line_start":39,"line_end":39,"column_start":5,"column_end":26,"is_primary":false,"text":[{"text":"    coeff: &Vec<Vec<f64>>,","highlight_start":5,"highlight_end":26}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/density.rs","byte_start":800,"byte_end":818,"line_start":38,"line_end":38,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"pub fn build_spin_density(","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:83:45\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let p_beta_new = build_spin_density(&c_b, n_beta);\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Vec<Vec<f64>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/density.rs:38:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_spin_density(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: &Vec<Vec<f64>>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2831,"byte_end":2835,"line_start":86,"line_end":86,"column_start":58,"column_end":62,"is_primary":false,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":58,"highlight_end":62}],"label":"unexpected argument #4 of type `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2837,"byte_end":2844,"line_start":86,"line_end":86,"column_start":64,"column_end":71,"is_primary":false,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":64,"highlight_end":71}],"label":"unexpected argument #5 of type `f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2786,"byte_end":2810,"line_start":86,"line_end":86,"column_start":13,"column_end":37,"is_primary":true,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":13,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2827,"byte_end":2829,"line_start":86,"line_end":86,"column_start":54,"column_end":56,"is_primary":true,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":54,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2379,"byte_end":2398,"line_start":92,"line_end":92,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2295,"byte_end":2319,"line_start":89,"line_end":89,"column_start":8,"column_end":32,"is_primary":true,"text":[{"text":"pub fn electronic_energy_scaled(","highlight_start":8,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2829,"byte_end":2835,"line_start":86,"line_end":86,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":56,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2835,"byte_end":2844,"line_start":86,"line_end":86,"column_start":62,"column_end":71,"is_primary":true,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":62,"highlight_end":71}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2827,"byte_end":2829,"line_start":86,"line_end":86,"column_start":54,"column_end":56,"is_primary":true,"text":[{"text":"            electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)","highlight_start":54,"highlight_end":56}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:86:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m                     \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94munexpected argument #5 of type `f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[94munexpected argument #4 of type `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:86:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             electronic_energy_scaled(&p_tot, &hcore, &j, &k_a, hf_frac)\n   \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:89:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn electronic_energy_scaled(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[91m- \u001b[0m            electronic_energy_scaled(&p_tot, &hcore, \u001b[91m&j, &k_a, hf_frac\u001b[0m)\n\u001b[1m\u001b[94m86\u001b[0m \u001b[92m+ \u001b[0m            electronic_energy_scaled(&p_tot, &hcore, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/udft.rs","byte_start":2903,"byte_end":2907,"line_start":87,"line_end":87,"column_start":58,"column_end":62,"is_primary":false,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":58,"highlight_end":62}],"label":"unexpected argument #4 of type `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2909,"byte_end":2916,"line_start":87,"line_end":87,"column_start":64,"column_end":71,"is_primary":false,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":64,"highlight_end":71}],"label":"unexpected argument #5 of type `f64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2858,"byte_end":2882,"line_start":87,"line_end":87,"column_start":13,"column_end":37,"is_primary":true,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":13,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/udft.rs","byte_start":2899,"byte_end":2901,"line_start":87,"line_end":87,"column_start":54,"column_end":56,"is_primary":true,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":54,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2379,"byte_end":2398,"line_start":92,"line_end":92,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2295,"byte_end":2319,"line_start":89,"line_end":89,"column_start":8,"column_end":32,"is_primary":true,"text":[{"text":"pub fn electronic_energy_scaled(","highlight_start":8,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/udft.rs","byte_start":2901,"byte_end":2907,"line_start":87,"line_end":87,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":56,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2907,"byte_end":2916,"line_start":87,"line_end":87,"column_start":62,"column_end":71,"is_primary":true,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":62,"highlight_end":71}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/udft.rs","byte_start":2899,"byte_end":2901,"line_start":87,"line_end":87,"column_start":54,"column_end":56,"is_primary":true,"text":[{"text":"          + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);","highlight_start":54,"highlight_end":56}],"label":null,"suggested_replacement":"/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:87:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m                     \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94munexpected argument #5 of type `f64`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                                          \u001b[1m\u001b[94munexpected argument #4 of type `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/udft.rs:87:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           + electronic_energy_scaled(&p_tot, &hcore, &j, &k_b, hf_frac);\n   \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[92m^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:89:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn electronic_energy_scaled(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[91m- \u001b[0m          + electronic_energy_scaled(&p_tot, &hcore, \u001b[91m&j, &k_b, hf_frac\u001b[0m);\n\u001b[1m\u001b[94m87\u001b[0m \u001b[92m+ \u001b[0m          + electronic_energy_scaled(&p_tot, &hcore, \u001b[92m/* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */\u001b[0m);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/utils.rs","byte_start":956,"byte_end":964,"line_start":38,"line_end":38,"column_start":70,"column_end":78,"is_primary":true,"text":[{"text":"    let nao = shells.last().unwrap().offset + shells.last().unwrap().orbitals.len();","highlight_start":70,"highlight_end":78}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:38:70\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let nao = shells.last().unwrap().offset + shells.last().unwrap().orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                                                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `kinetic` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/utils.rs","byte_start":1237,"byte_end":1244,"line_start":46,"line_end":46,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"            let t = si.kinetic(sj, *ci, *cj);","highlight_start":24,"highlight_end":31}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `kinetic` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:46:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let t = si.kinetic(sj, *ci, *cj);\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `nuclear_attraction` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/utils.rs","byte_start":1283,"byte_end":1301,"line_start":47,"line_end":47,"column_start":24,"column_end":42,"is_primary":true,"text":[{"text":"            let v = si.nuclear_attraction(sj, *ci, *cj, atoms);","highlight_start":24,"highlight_end":42}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `nuclear_attraction` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:47:24\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let v = si.nuclear_attraction(sj, *ci, *cj, atoms);\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/utils.rs","byte_start":1353,"byte_end":1361,"line_start":49,"line_end":49,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"            for mu in 0..si.orbitals.len() {","highlight_start":29,"highlight_end":37}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:49:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for mu in 0..si.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/utils.rs","byte_start":1402,"byte_end":1410,"line_start":50,"line_end":50,"column_start":33,"column_end":41,"is_primary":true,"text":[{"text":"                for nu in 0..sj.orbitals.len() {","highlight_start":33,"highlight_end":41}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:50:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for nu in 0..sj.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":555,"byte_end":563,"line_start":15,"line_end":15,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"    let nao = shells.iter().map(|s| s.orbitals.len()).sum::<usize>();","highlight_start":39,"highlight_end":47}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:15:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let nao = shells.iter().map(|s| s.orbitals.len()).sum::<usize>();\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":705,"byte_end":707,"line_start":19,"line_end":19,"column_start":32,"column_end":34,"is_primary":false,"text":[{"text":"        overlap_shell_shell(a, ca, b, cb)","highlight_start":32,"highlight_end":34}],"label":"unexpected argument #2 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":712,"byte_end":714,"line_start":19,"line_end":19,"column_start":39,"column_end":41,"is_primary":false,"text":[{"text":"        overlap_shell_shell(a, ca, b, cb)","highlight_start":39,"highlight_end":41}],"label":"unexpected argument #4 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":682,"byte_end":701,"line_start":19,"line_end":19,"column_start":9,"column_end":28,"is_primary":true,"text":[{"text":"        overlap_shell_shell(a, ca, b, cb)","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/integrals/overlap_contracted.rs","byte_start":624,"byte_end":643,"line_start":28,"line_end":28,"column_start":8,"column_end":27,"is_primary":true,"text":[{"text":"pub fn overlap_shell_shell(","highlight_start":8,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/guess.rs","byte_start":703,"byte_end":707,"line_start":19,"line_end":19,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"        overlap_shell_shell(a, ca, b, cb)","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/guess.rs","byte_start":710,"byte_end":714,"line_start":19,"line_end":19,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        overlap_shell_shell(a, ca, b, cb)","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 2 arguments but 4 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:19:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         overlap_shell_shell(a, ca, b, cb)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m    \u001b[1m\u001b[94m--\u001b[0m     \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94munexpected argument #2 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/overlap_contracted.rs:28:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn overlap_shell_shell(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[91m- \u001b[0m        overlap_shell_shell(a\u001b[91m, ca\u001b[0m, b\u001b[91m, cb\u001b[0m)\n\u001b[1m\u001b[94m19\u001b[0m \u001b[92m+ \u001b[0m        overlap_shell_shell(a, b)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":820,"byte_end":822,"line_start":22,"line_end":22,"column_start":32,"column_end":34,"is_primary":false,"text":[{"text":"        kinetic_shell_shell(a, ca, b, cb)","highlight_start":32,"highlight_end":34}],"label":"unexpected argument #2 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":827,"byte_end":829,"line_start":22,"line_end":22,"column_start":39,"column_end":41,"is_primary":false,"text":[{"text":"        kinetic_shell_shell(a, ca, b, cb)","highlight_start":39,"highlight_end":41}],"label":"unexpected argument #4 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":797,"byte_end":816,"line_start":22,"line_end":22,"column_start":9,"column_end":28,"is_primary":true,"text":[{"text":"        kinetic_shell_shell(a, ca, b, cb)","highlight_start":9,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/integrals/kinetic.rs","byte_start":1747,"byte_end":1766,"line_start":75,"line_end":75,"column_start":8,"column_end":27,"is_primary":true,"text":[{"text":"pub fn kinetic_shell_shell(","highlight_start":8,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/guess.rs","byte_start":818,"byte_end":822,"line_start":22,"line_end":22,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"        kinetic_shell_shell(a, ca, b, cb)","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/guess.rs","byte_start":825,"byte_end":829,"line_start":22,"line_end":22,"column_start":37,"column_end":41,"is_primary":true,"text":[{"text":"        kinetic_shell_shell(a, ca, b, cb)","highlight_start":37,"highlight_end":41}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 2 arguments but 4 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:22:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         kinetic_shell_shell(a, ca, b, cb)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m    \u001b[1m\u001b[94m--\u001b[0m     \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94munexpected argument #2 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/kinetic.rs:75:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn kinetic_shell_shell(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[91m- \u001b[0m        kinetic_shell_shell(a\u001b[91m, ca\u001b[0m, b\u001b[91m, cb\u001b[0m)\n\u001b[1m\u001b[94m22\u001b[0m \u001b[92m+ \u001b[0m        kinetic_shell_shell(a, b)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 3 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":946,"byte_end":948,"line_start":25,"line_end":25,"column_start":43,"column_end":45,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":43,"highlight_end":45}],"label":"unexpected argument #2 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":953,"byte_end":955,"line_start":25,"line_end":25,"column_start":50,"column_end":52,"is_primary":false,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":50,"highlight_end":52}],"label":"unexpected argument #4 of type `[f64; 3]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":912,"byte_end":942,"line_start":25,"line_end":25,"column_start":9,"column_end":39,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":9,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/integrals/nuclear_attraction.rs","byte_start":1888,"byte_end":1918,"line_start":85,"line_end":85,"column_start":8,"column_end":38,"is_primary":true,"text":[{"text":"pub fn nuclear_attraction_shell_shell(","highlight_start":8,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra arguments","code":null,"level":"help","spans":[{"file_name":"src/scf/guess.rs","byte_start":944,"byte_end":948,"line_start":25,"line_end":25,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":41,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/scf/guess.rs","byte_start":951,"byte_end":955,"line_start":25,"line_end":25,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        nuclear_attraction_shell_shell(a, ca, b, cb, atoms)","highlight_start":48,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 3 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:25:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         nuclear_attraction_shell_shell(a, ca, b, cb, atoms)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m    \u001b[1m\u001b[94m--\u001b[0m     \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94munexpected argument #2 of type `[f64; 3]`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/nuclear_attraction.rs:85:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn nuclear_attraction_shell_shell(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[91m- \u001b[0m        nuclear_attraction_shell_shell(a\u001b[91m, ca\u001b[0m, b\u001b[91m, cb\u001b[0m, atoms)\n\u001b[1m\u001b[94m25\u001b[0m \u001b[92m+ \u001b[0m        nuclear_attraction_shell_shell(a, b, atoms)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":1055,"byte_end":1069,"line_start":31,"line_end":31,"column_start":22,"column_end":36,"is_primary":true,"text":[{"text":"    let (coeff, _) = solve_roothaan(&hcore, &s);","highlight_start":22,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/guess.rs","byte_start":1070,"byte_end":1076,"line_start":31,"line_end":31,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"    let (coeff, _) = solve_roothaan(&hcore, &s);","highlight_start":37,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/scf/guess.rs","byte_start":1078,"byte_end":1080,"line_start":31,"line_end":31,"column_start":45,"column_end":47,"is_primary":true,"text":[{"text":"    let (coeff, _) = solve_roothaan(&hcore, &s);","highlight_start":45,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/utils.rs","byte_start":2794,"byte_end":2813,"line_start":113,"line_end":113,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    fock: &DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2819,"byte_end":2841,"line_start":114,"line_end":114,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    overlap: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/utils.rs","byte_start":2774,"byte_end":2788,"line_start":112,"line_end":112,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn solve_roothaan(","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:31:22\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let (coeff, _) = solve_roothaan(&hcore, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:31:37\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let (coeff, _) = solve_roothaan(&hcore, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[92m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:31:45\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let (coeff, _) = solve_roothaan(&hcore, &s);\n    \u001b[1m\u001b[94m|\u001b[0m                                             \u001b[1m\u001b[92m^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/scf/utils.rs:112:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn solve_roothaan(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fock: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[94m114\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     overlap: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":1123,"byte_end":1129,"line_start":34,"line_end":34,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"    build_density(&coeff, n_electrons)","highlight_start":19,"highlight_end":25}],"label":"expected `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/guess.rs","byte_start":1109,"byte_end":1122,"line_start":34,"line_end":34,"column_start":5,"column_end":18,"is_primary":false,"text":[{"text":"    build_density(&coeff, n_electrons)","highlight_start":5,"highlight_end":18}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Matrix<_, _, _, _>`\nfound reference `&Matrix<_, _, _, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/scf/density.rs","byte_start":281,"byte_end":300,"line_start":15,"line_end":15,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"    coeff: DMatrix<f64>,","highlight_start":5,"highlight_end":24}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/scf/density.rs","byte_start":262,"byte_end":275,"line_start":14,"line_end":14,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"pub fn build_density(","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/scf/guess.rs","byte_start":1123,"byte_end":1124,"line_start":34,"line_end":34,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"    build_density(&coeff, n_electrons)","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:34:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     build_density(&coeff, n_electrons)\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Matrix<_, _, _, _>`\n           found reference `\u001b[1m\u001b[35m&\u001b[0mMatrix<_, _, _, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/density.rs:14:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn build_density(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m15\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     coeff: DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider removing the borrow\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[91m- \u001b[0m    build_density(\u001b[91m&\u001b[0mcoeff, n_electrons)\n\u001b[1m\u001b[94m34\u001b[0m \u001b[92m+ \u001b[0m    build_density(coeff, n_electrons)\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":1363,"byte_end":1371,"line_start":45,"line_end":45,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"    let nao = shells.iter().map(|s| s.orbitals.len()).sum::<usize>();","highlight_start":39,"highlight_end":47}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:45:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let nao = shells.iter().map(|s| s.orbitals.len()).sum::<usize>();\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/scf/guess.rs","byte_start":1564,"byte_end":1572,"line_start":52,"line_end":52,"column_start":19,"column_end":27,"is_primary":true,"text":[{"text":"        off += sh.orbitals.len();","highlight_start":19,"highlight_end":27}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/guess.rs:52:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         off += sh.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `grad_kinetic_nuclear` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/one_electron.rs","byte_start":529,"byte_end":537,"line_start":20,"line_end":20,"column_start":27,"column_end":35,"is_primary":false,"text":[{"text":"                let d_h = shell_i.grad_kinetic_nuclear(","highlight_start":27,"highlight_end":35}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/one_electron.rs","byte_start":537,"byte_end":557,"line_start":20,"line_end":20,"column_start":35,"column_end":55,"is_primary":true,"text":[{"text":"                let d_h = shell_i.grad_kinetic_nuclear(","highlight_start":35,"highlight_end":55}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `grad_kinetic_nuclear` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/one_electron.rs:20:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let d_h = shell_i.grad_kinetic_nuclear(\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m--------\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/one_electron.rs","byte_start":750,"byte_end":758,"line_start":27,"line_end":27,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"                for mu in 0..shell_i.orbitals.len() {","highlight_start":38,"highlight_end":46}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/one_electron.rs:27:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for mu in 0..shell_i.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/one_electron.rs","byte_start":808,"byte_end":816,"line_start":28,"line_end":28,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"                    for nu in 0..shell_j.orbitals.len() {","highlight_start":42,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/one_electron.rs:28:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for nu in 0..shell_j.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `grad_overlap` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap_pulay.rs","byte_start":314,"byte_end":326,"line_start":14,"line_end":14,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"            let dS = shell_i.grad_overlap(&shell_j);","highlight_start":30,"highlight_end":42}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `grad_overlap` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap_pulay.rs:14:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let dS = shell_i.grad_overlap(&shell_j);\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap_pulay.rs","byte_start":372,"byte_end":380,"line_start":16,"line_end":16,"column_start":34,"column_end":42,"is_primary":true,"text":[{"text":"            for mu in 0..shell_i.orbitals.len() {","highlight_start":34,"highlight_end":42}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap_pulay.rs:16:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for mu in 0..shell_i.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap_pulay.rs","byte_start":426,"byte_end":434,"line_start":17,"line_end":17,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"                for nu in 0..shell_j.orbitals.len() {","highlight_start":38,"highlight_end":46}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap_pulay.rs:17:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for nu in 0..shell_j.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `as_ref` found for enum `XcMethod` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2214,"byte_end":2220,"line_start":74,"line_end":74,"column_start":26,"column_end":32,"is_primary":true,"text":[{"text":"            match method.as_ref() {","highlight_start":26,"highlight_end":32}],"label":"method not found in `XcMethod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":913,"byte_end":930,"line_start":43,"line_end":43,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub enum XcMethod {","highlight_start":1,"highlight_end":18}],"label":"method `as_ref` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `as_ref`, perhaps you need to implement it:\ncandidate #1: `AsRef`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `as_ref` found for enum `XcMethod` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:74:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             match method.as_ref() {\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `XcMethod`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/dft/vxc.rs:43:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum XcMethod {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mmethod `as_ref` not found for this enum\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait defines an item `as_ref`, perhaps you need to implement it:\n           candidate #1: `AsRef`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2314,"byte_end":2327,"line_start":76,"line_end":76,"column_start":44,"column_end":57,"is_primary":true,"text":[{"text":"                | XcMethod::Hybrid { base: XcMethod::LDA, .. }","highlight_start":44,"highlight_end":57}],"label":"expected `Box<XcMethod>`, found `XcMethod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/total.rs","byte_start":2207,"byte_end":2222,"line_start":74,"line_end":74,"column_start":19,"column_end":34,"is_primary":false,"text":[{"text":"            match method.as_ref() {","highlight_start":19,"highlight_end":34}],"label":"this expression has type `{type error}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":937,"byte_end":940,"line_start":44,"line_end":44,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    LDA,","highlight_start":5,"highlight_end":8}],"label":"unit variant defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<XcMethod>`\n     found enum `XcMethod`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:76:44\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             match method.as_ref() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `{type error}`\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 XcMethod::LDA | XcMethod::GGA\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 | XcMethod::Hybrid { base: XcMethod::LDA, .. }\n   \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<XcMethod>`, found `XcMethod`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/dft/vxc.rs:44:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     LDA,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94munit variant defined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mXcMethod\u001b[1m\u001b[35m>\u001b[0m`\n                found enum `XcMethod`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2377,"byte_end":2390,"line_start":77,"line_end":77,"column_start":44,"column_end":57,"is_primary":true,"text":[{"text":"                | XcMethod::Hybrid { base: XcMethod::GGA, .. } => {","highlight_start":44,"highlight_end":57}],"label":"expected `Box<XcMethod>`, found `XcMethod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/total.rs","byte_start":2207,"byte_end":2222,"line_start":74,"line_end":74,"column_start":19,"column_end":34,"is_primary":false,"text":[{"text":"            match method.as_ref() {","highlight_start":19,"highlight_end":34}],"label":"this expression has type `{type error}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":946,"byte_end":949,"line_start":45,"line_end":45,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    GGA,","highlight_start":5,"highlight_end":8}],"label":"unit variant defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<XcMethod>`\n     found enum `XcMethod`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:77:44\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             match method.as_ref() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `{type error}`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 | XcMethod::Hybrid { base: XcMethod::GGA, .. } => {\n   \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<XcMethod>`, found `XcMethod`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/dft/vxc.rs:45:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     GGA,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94munit variant defined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mXcMethod\u001b[1m\u001b[35m>\u001b[0m`\n                found enum `XcMethod`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2913,"byte_end":2930,"line_start":95,"line_end":95,"column_start":44,"column_end":61,"is_primary":true,"text":[{"text":"                | XcMethod::Hybrid { base: XcMethod::MetaGGA, .. } => {","highlight_start":44,"highlight_end":61}],"label":"expected `Box<XcMethod>`, found `XcMethod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/total.rs","byte_start":2207,"byte_end":2222,"line_start":74,"line_end":74,"column_start":19,"column_end":34,"is_primary":false,"text":[{"text":"            match method.as_ref() {","highlight_start":19,"highlight_end":34}],"label":"this expression has type `{type error}`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":955,"byte_end":962,"line_start":46,"line_end":46,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    MetaGGA,","highlight_start":5,"highlight_end":12}],"label":"unit variant defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<XcMethod>`\n     found enum `XcMethod`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:95:44\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             match method.as_ref() {\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `{type error}`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 | XcMethod::Hybrid { base: XcMethod::MetaGGA, .. } => {\n   \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<XcMethod>`, found `XcMethod`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/dft/vxc.rs:46:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     MetaGGA,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94munit variant defined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mXcMethod\u001b[1m\u001b[35m>\u001b[0m`\n                found enum `XcMethod`\n\n"}
{"$message_type":"diagnostic","message":"this function takes 7 arguments but 5 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2603,"byte_end":2609,"line_start":84,"line_end":84,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"                        method,","highlight_start":25,"highlight_end":31}],"label":"expected `usize`, found `XcMethod`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/total.rs","byte_start":2448,"byte_end":2632,"line_start":79,"line_end":85,"column_start":46,"column_end":22,"is_primary":false,"text":[{"text":"                    let gxc = grad_xc_lda_gga(","highlight_start":46,"highlight_end":47},{"text":"                        shells,","highlight_start":1,"highlight_end":32},{"text":"                        shell_centers,","highlight_start":1,"highlight_end":39},{"text":"                        p,","highlight_start":1,"highlight_end":27},{"text":"                        atoms,","highlight_start":1,"highlight_end":31},{"text":"                        method,","highlight_start":1,"highlight_end":32},{"text":"                    );","highlight_start":1,"highlight_end":22}],"label":"two arguments of type `usize` and `bool` are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/total.rs","byte_start":2433,"byte_end":2448,"line_start":79,"line_end":79,"column_start":31,"column_end":46,"is_primary":true,"text":[{"text":"                    let gxc = grad_xc_lda_gga(","highlight_start":31,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/gradients/total.rs","byte_start":2545,"byte_end":2546,"line_start":82,"line_end":82,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"                        p,","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":614,"byte_end":636,"line_start":26,"line_end":26,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc.rs","byte_start":662,"byte_end":673,"line_start":28,"line_end":28,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"    atom: usize,","highlight_start":5,"highlight_end":16}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc.rs","byte_start":679,"byte_end":690,"line_start":29,"line_end":29,"column_start":5,"column_end":16,"is_primary":false,"text":[{"text":"    axis: usize,","highlight_start":5,"highlight_end":16}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc.rs","byte_start":696,"byte_end":708,"line_start":30,"line_end":30,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    is_gga: bool,","highlight_start":5,"highlight_end":17}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc.rs","byte_start":539,"byte_end":554,"line_start":23,"line_end":23,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"pub fn grad_xc_lda_gga(","highlight_start":8,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/gradients/total.rs","byte_start":2448,"byte_end":2632,"line_start":79,"line_end":85,"column_start":46,"column_end":22,"is_primary":true,"text":[{"text":"                    let gxc = grad_xc_lda_gga(","highlight_start":46,"highlight_end":47},{"text":"                        shells,","highlight_start":1,"highlight_end":32},{"text":"                        shell_centers,","highlight_start":1,"highlight_end":39},{"text":"                        p,","highlight_start":1,"highlight_end":27},{"text":"                        atoms,","highlight_start":1,"highlight_end":31},{"text":"                        method,","highlight_start":1,"highlight_end":32},{"text":"                    );","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":"(\n                        shells,\n                        shell_centers,\n                        /* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */,\n                        atoms,\n                        /* usize */,\n                        /* usize */,\n                        /* bool */,\n                    )","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 7 arguments but 5 arguments were supplied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:79:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                       let gxc = grad_xc_lda_gga(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________________________\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         shells,\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         shell_centers,\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         p,\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         atoms,\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         method,\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mexpected `usize`, found `XcMethod`\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     );\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________-\u001b[0m \u001b[1m\u001b[94mtwo arguments of type `usize` and `bool` are missing\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:82:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         p,\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:23:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn grad_xc_lda_gga(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atoms: &[Atom],\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     atom: usize,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     axis: usize,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     is_gga: bool,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the arguments\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[92m~ \u001b[0m                    let gxc = grad_xc_lda_gga\u001b[92m(\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[92m+                         shells,\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[92m+                         shell_centers,\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[92m+                         /* &Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>> */,\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[92m+                         atoms,\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[92m+                         /* usize */,\u001b[0m\n\u001b[1m\u001b[94m85\u001b[0m \u001b[92m+                         /* usize */,\u001b[0m\n\u001b[1m\u001b[94m86\u001b[0m \u001b[92m+                         /* bool */,\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[92m~                     )\u001b[0m;\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `f64`","code":{"code":"E0608","explanation":"Attempted to index a value whose type doesn't implement the\n`std::ops::Index` trait.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nOnly values with types that implement the `std::ops::Index` trait\ncan be indexed with square brackets. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n\nTuples and structs are indexed with dot (`.`), not with brackets (`[]`),\nand tuple element names are their positions:\n```ignore(pseudo code)\n// this (pseudo code) expression is true for any tuple:\ntuple == (tuple.0, tuple.1, ...)\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/total.rs","byte_start":2764,"byte_end":2767,"line_start":89,"line_end":89,"column_start":49,"column_end":52,"is_primary":true,"text":[{"text":"                            grad[a][k] += gxc[a][k];","highlight_start":49,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0608]\u001b[0m\u001b[1m: cannot index into a value of type `f64`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/total.rs:89:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   grad[a][k] += gxc[a][k];\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap.rs","byte_start":506,"byte_end":514,"line_start":21,"line_end":21,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"            + shells.last().unwrap().orbitals.len();","highlight_start":38,"highlight_end":46}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap.rs:21:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             + shells.last().unwrap().orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap.rs","byte_start":680,"byte_end":688,"line_start":27,"line_end":27,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        let ni = si.orbitals.len();","highlight_start":21,"highlight_end":29}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap.rs:27:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let ni = si.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap.rs","byte_start":822,"byte_end":830,"line_start":31,"line_end":31,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"            let nj = sj.orbitals.len();","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap.rs:31:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let nj = sj.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `first_deriv_overlap` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/overlap.rs","byte_start":879,"byte_end":898,"line_start":34,"line_end":34,"column_start":20,"column_end":39,"is_primary":true,"text":[{"text":"                si.first_deriv_overlap(sj, *ci, *cj, natoms);","highlight_start":20,"highlight_end":39}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `first_deriv_overlap` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/overlap.rs:34:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 si.first_deriv_overlap(sj, *ci, *cj, natoms);\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":984,"byte_end":992,"line_start":35,"line_end":35,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        let ni = si.orbitals.len();","highlight_start":21,"highlight_end":29}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:35:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let ni = si.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":1126,"byte_end":1134,"line_start":39,"line_end":39,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"            let nj = sj.orbitals.len();","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:39:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let nj = sj.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_kinetic` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":1183,"byte_end":1203,"line_start":42,"line_end":42,"column_start":20,"column_end":40,"is_primary":true,"text":[{"text":"                si.second_deriv_kinetic(sj, *ci, *cj, atoms);","highlight_start":20,"highlight_end":40}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_kinetic` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:42:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 si.second_deriv_kinetic(sj, *ci, *cj, atoms);\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_nuclear_attraction` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":1267,"byte_end":1298,"line_start":45,"line_end":45,"column_start":20,"column_end":51,"is_primary":true,"text":[{"text":"                si.second_deriv_nuclear_attraction(sj, *ci, *cj, atoms);","highlight_start":20,"highlight_end":51}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_nuclear_attraction` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:45:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 si.second_deriv_nuclear_attraction(sj, *ci, *cj, atoms);\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `first_deriv_eri` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":1920,"byte_end":1935,"line_start":66,"line_end":66,"column_start":28,"column_end":43,"is_primary":true,"text":[{"text":"                        si.first_deriv_eri(sj, sk, sl, atoms.len());","highlight_start":28,"highlight_end":43}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `first_deriv_eri` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:66:28\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         si.first_deriv_eri(sj, sk, sl, atoms.len());\n   \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":1999,"byte_end":2007,"line_start":68,"line_end":68,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    for mu in 0..si.orbitals.len() {","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:68:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for mu in 0..si.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":2056,"byte_end":2064,"line_start":69,"line_end":69,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"                        for nu in 0..sj.orbitals.len() {","highlight_start":41,"highlight_end":49}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:69:41\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         for nu in 0..sj.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":2269,"byte_end":2277,"line_start":74,"line_end":74,"column_start":45,"column_end":53,"is_primary":true,"text":[{"text":"                            for la in 0..sk.orbitals.len() {","highlight_start":45,"highlight_end":53}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:74:45\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   for la in 0..sk.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":2335,"byte_end":2343,"line_start":75,"line_end":75,"column_start":50,"column_end":58,"is_primary":true,"text":[{"text":"                                for si2 in 0..sl.orbitals.len() {","highlight_start":50,"highlight_end":58}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:75:50\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   for si2 in 0..sl.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `first_deriv_eri` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":3141,"byte_end":3156,"line_start":100,"line_end":100,"column_start":28,"column_end":43,"is_primary":true,"text":[{"text":"                        si.first_deriv_eri(sj, sk, sl, atoms.len());","highlight_start":28,"highlight_end":43}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `first_deriv_eri` found for reference `&Shell` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:100:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m100\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         si.first_deriv_eri(sj, sk, sl, atoms.len());\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":3220,"byte_end":3228,"line_start":102,"line_end":102,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    for mu in 0..si.orbitals.len() {","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:102:37\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for mu in 0..si.orbitals.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":3277,"byte_end":3285,"line_start":103,"line_end":103,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"                        for nu in 0..sj.orbitals.len() {","highlight_start":41,"highlight_end":49}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:103:41\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         for nu in 0..sj.orbitals.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":3490,"byte_end":3498,"line_start":108,"line_end":108,"column_start":45,"column_end":53,"is_primary":true,"text":[{"text":"                            for la in 0..sk.orbitals.len() {","highlight_start":45,"highlight_end":53}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:108:45\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   for la in 0..sk.orbitals.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":3556,"byte_end":3564,"line_start":109,"line_end":109,"column_start":50,"column_end":58,"is_primary":true,"text":[{"text":"                                for si2 in 0..sl.orbitals.len() {","highlight_start":50,"highlight_end":58}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:109:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   for si2 in 0..sl.orbitals.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `build_vxc_derivative` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/gradients/fock.rs","byte_start":4237,"byte_end":4257,"line_start":130,"line_end":130,"column_start":13,"column_end":33,"is_primary":true,"text":[{"text":"            build_vxc_derivative(","highlight_start":13,"highlight_end":33}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `build_vxc_derivative` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/fock.rs:130:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m130\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             build_vxc_derivative(\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":1940,"byte_end":1948,"line_start":72,"line_end":72,"column_start":33,"column_end":41,"is_primary":true,"text":[{"text":"                for mu in 0..si.orbitals.len() {","highlight_start":33,"highlight_end":41}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:72:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for mu in 0..si.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":1993,"byte_end":2001,"line_start":73,"line_end":73,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    let phi_mu = si.orbitals[mu].value(*ci, pt.r);","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:73:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let phi_mu = si.orbitals[mu].value(*ci, pt.r);\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":2061,"byte_end":2069,"line_start":74,"line_end":74,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"                    let dphi_mu = si.orbitals[mu].gradient(*ci, pt.r)[axis];","highlight_start":38,"highlight_end":46}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:74:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let dphi_mu = si.orbitals[mu].gradient(*ci, pt.r)[axis];\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":2138,"byte_end":2146,"line_start":76,"line_end":76,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    for nu in 0..sj.orbitals.len() {","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:76:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     for nu in 0..sj.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":2195,"byte_end":2203,"line_start":77,"line_end":77,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"                        let phi_nu = sj.orbitals[nu].value(*cj, pt.r);","highlight_start":41,"highlight_end":49}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:77:41\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         let phi_nu = sj.orbitals[nu].value(*cj, pt.r);\n   \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc.rs","byte_start":2267,"byte_end":2275,"line_start":78,"line_end":78,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"                        let dphi_nu = sj.orbitals[nu].gradient(*cj, pt.r)[axis];","highlight_start":42,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc.rs:78:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         let dphi_nu = sj.orbitals[nu].gradient(*cj, pt.r)[axis];\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":650,"byte_end":658,"line_start":23,"line_end":23,"column_start":14,"column_end":22,"is_primary":true,"text":[{"text":"        m => (m, 0.0),","highlight_start":14,"highlight_end":22}],"label":"expected `(Box<XcMethod>, f64)`, found `(XcMethod, {float})`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":610,"byte_end":635,"line_start":22,"line_end":22,"column_start":43,"column_end":68,"is_primary":false,"text":[{"text":"        XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),","highlight_start":43,"highlight_end":68}],"label":"this is found to be of type `(Box<XcMethod>, f64)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":553,"byte_end":665,"line_start":21,"line_end":24,"column_start":30,"column_end":6,"is_primary":false,"text":[{"text":"    let (xc_base, hf_frac) = match method {","highlight_start":30,"highlight_end":44},{"text":"        XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),","highlight_start":1,"highlight_end":69},{"text":"        m => (m, 0.0),","highlight_start":1,"highlight_end":23},{"text":"    };","highlight_start":1,"highlight_end":6}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected tuple `(Box<XcMethod>, f64)`\n   found tuple `(XcMethod, {float})`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_meta.rs:23:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let (xc_base, hf_frac) = match method {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________-\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mthis is found to be of type `(Box<XcMethod>, f64)`\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         m => (m, 0.0),\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `(Box<XcMethod>, f64)`, found `(XcMethod, {float})`\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     };\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____-\u001b[0m \u001b[1m\u001b[94m`match` arms have incompatible types\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected tuple `(\u001b[1m\u001b[35mBox<\u001b[0mXcMethod\u001b[1m\u001b[35m>\u001b[0m, \u001b[1m\u001b[35mf64\u001b[0m)`\n              found tuple `(XcMethod, \u001b[1m\u001b[35m{float}\u001b[0m)`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":1060,"byte_end":1067,"line_start":37,"line_end":37,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"        let dp = density_at_point(shells, centers, density, r);","highlight_start":52,"highlight_end":59}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":1026,"byte_end":1042,"line_start":37,"line_end":37,"column_start":18,"column_end":34,"is_primary":false,"text":[{"text":"        let dp = density_at_point(shells, centers, density, r);","highlight_start":18,"highlight_end":34}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/density.rs","byte_start":725,"byte_end":747,"line_start":31,"line_end":31,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":649,"byte_end":665,"line_start":28,"line_end":28,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"pub fn density_at_point(","highlight_start":8,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_meta.rs:37:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dp = density_at_point(shells, centers, density, r);\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m----------------\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:28:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn density_at_point(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":1831,"byte_end":1839,"line_start":56,"line_end":56,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"            for ao in &sh.orbitals {","highlight_start":27,"highlight_end":35}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_meta.rs:56:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for ao in &sh.orbitals {\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_meta.rs","byte_start":1867,"byte_end":1869,"line_start":57,"line_end":57,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"                phi.push(ao.value(*c, r));","highlight_start":26,"highlight_end":28}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_meta.rs:57:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 phi.push(ao.value(*c, r));\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":731,"byte_end":739,"line_start":27,"line_end":27,"column_start":14,"column_end":22,"is_primary":true,"text":[{"text":"        m => (m, 0.0),","highlight_start":14,"highlight_end":22}],"label":"expected `(Box<XcMethod>, f64)`, found `(XcMethod, {float})`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":691,"byte_end":716,"line_start":26,"line_end":26,"column_start":43,"column_end":68,"is_primary":false,"text":[{"text":"        XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),","highlight_start":43,"highlight_end":68}],"label":"this is found to be of type `(Box<XcMethod>, f64)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":634,"byte_end":746,"line_start":25,"line_end":28,"column_start":30,"column_end":6,"is_primary":false,"text":[{"text":"    let (xc_base, hf_frac) = match method {","highlight_start":30,"highlight_end":44},{"text":"        XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),","highlight_start":1,"highlight_end":69},{"text":"        m => (m, 0.0),","highlight_start":1,"highlight_end":23},{"text":"    };","highlight_start":1,"highlight_end":6}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected tuple `(Box<XcMethod>, f64)`\n   found tuple `(XcMethod, {float})`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:27:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let (xc_base, hf_frac) = match method {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______________________________-\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         XcMethod::Hybrid { base, hyb } => (base, hyb.hf_fraction()),\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mthis is found to be of type `(Box<XcMethod>, f64)`\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         m => (m, 0.0),\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `(Box<XcMethod>, f64)`, found `(XcMethod, {float})`\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     };\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____-\u001b[0m \u001b[1m\u001b[94m`match` arms have incompatible types\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected tuple `(\u001b[1m\u001b[35mBox<\u001b[0mXcMethod\u001b[1m\u001b[35m>\u001b[0m, \u001b[1m\u001b[35mf64\u001b[0m)`\n              found tuple `(XcMethod, \u001b[1m\u001b[35m{float}\u001b[0m)`\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":1147,"byte_end":1168,"line_start":45,"line_end":45,"column_start":18,"column_end":39,"is_primary":true,"text":[{"text":"        let dp = spin_density_at_point(","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":1229,"byte_end":1236,"line_start":48,"line_end":48,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            p_alpha,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":1250,"byte_end":1256,"line_start":49,"line_end":49,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"            p_beta,","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/density.rs","byte_start":2136,"byte_end":2164,"line_start":81,"line_end":81,"column_start":5,"column_end":33,"is_primary":false,"text":[{"text":"    density_alpha: &DMatrix<f64>,","highlight_start":5,"highlight_end":33}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":2170,"byte_end":2197,"line_start":82,"line_end":82,"column_start":5,"column_end":32,"is_primary":false,"text":[{"text":"    density_beta: &DMatrix<f64>,","highlight_start":5,"highlight_end":32}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":2055,"byte_end":2076,"line_start":78,"line_end":78,"column_start":8,"column_end":29,"is_primary":true,"text":[{"text":"pub fn spin_density_at_point(","highlight_start":8,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:45:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dp = spin_density_at_point(\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:48:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             p_alpha,\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:49:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             p_beta,\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[92m^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:78:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn spin_density_at_point(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density_alpha: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------------\u001b[0m\n\u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density_beta: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":1627,"byte_end":1635,"line_start":63,"line_end":63,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"            for ao in &shell.orbitals {","highlight_start":30,"highlight_end":38}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:63:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for ao in &shell.orbitals {\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/gradients/dft_xc_spin.rs","byte_start":1663,"byte_end":1665,"line_start":64,"line_end":64,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"                phi.push(ao.value(*center, r));","highlight_start":26,"highlight_end":28}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/dft_xc_spin.rs:64:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 phi.push(ao.value(*center, r));\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/one_electron.rs","byte_start":1012,"byte_end":1020,"line_start":37,"line_end":37,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        let ni = si.orbitals.len();","highlight_start":21,"highlight_end":29}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/one_electron.rs:37:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let ni = si.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/one_electron.rs","byte_start":1154,"byte_end":1162,"line_start":41,"line_end":41,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"            let nj = sj.orbitals.len();","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/one_electron.rs:41:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let nj = sj.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_kinetic` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/one_electron.rs","byte_start":1438,"byte_end":1458,"line_start":47,"line_end":47,"column_start":26,"column_end":46,"is_primary":true,"text":[{"text":"            let d2t = si.second_deriv_kinetic(sj, *ci, *cj, atoms);","highlight_start":26,"highlight_end":46}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_kinetic` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/one_electron.rs:47:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let d2t = si.second_deriv_kinetic(sj, *ci, *cj, atoms);\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_nuclear_attraction` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/one_electron.rs","byte_start":1725,"byte_end":1756,"line_start":53,"line_end":53,"column_start":26,"column_end":57,"is_primary":true,"text":[{"text":"            let d2v = si.second_deriv_nuclear_attraction(sj, *ci, *cj, atoms);","highlight_start":26,"highlight_end":57}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_nuclear_attraction` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/one_electron.rs:53:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let d2v = si.second_deriv_nuclear_attraction(sj, *ci, *cj, atoms);\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/overlap.rs","byte_start":1331,"byte_end":1339,"line_start":43,"line_end":43,"column_start":21,"column_end":29,"is_primary":true,"text":[{"text":"        let ni = si.orbitals.len();","highlight_start":21,"highlight_end":29}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/overlap.rs:43:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let ni = si.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/overlap.rs","byte_start":1473,"byte_end":1481,"line_start":47,"line_end":47,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"            let nj = sj.orbitals.len();","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/overlap.rs:47:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let nj = sj.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `first_deriv_overlap` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/overlap.rs","byte_start":1748,"byte_end":1767,"line_start":54,"line_end":54,"column_start":20,"column_end":39,"is_primary":true,"text":[{"text":"                si.first_deriv_overlap(sj, *ci, *cj, natoms);","highlight_start":20,"highlight_end":39}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `first_deriv_overlap` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/overlap.rs:54:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 si.first_deriv_overlap(sj, *ci, *cj, natoms);\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_overlap` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/overlap.rs","byte_start":2064,"byte_end":2084,"line_start":61,"line_end":61,"column_start":20,"column_end":40,"is_primary":true,"text":[{"text":"                si.second_deriv_overlap(sj, *ci, *cj, natoms);","highlight_start":20,"highlight_end":40}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_overlap` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/overlap.rs:61:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 si.second_deriv_overlap(sj, *ci, *cj, natoms);\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/two_electron.rs","byte_start":990,"byte_end":998,"line_start":36,"line_end":36,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"        let nmu = sh_mu.orbitals.len();","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/two_electron.rs:36:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let nmu = sh_mu.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/two_electron.rs","byte_start":1104,"byte_end":1112,"line_start":40,"line_end":40,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"            let nnu = sh_nu.orbitals.len();","highlight_start":29,"highlight_end":37}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/two_electron.rs:40:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let nnu = sh_nu.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/two_electron.rs","byte_start":1230,"byte_end":1238,"line_start":44,"line_end":44,"column_start":33,"column_end":41,"is_primary":true,"text":[{"text":"                let nla = sh_la.orbitals.len();","highlight_start":33,"highlight_end":41}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/two_electron.rs:44:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let nla = sh_la.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/two_electron.rs","byte_start":1368,"byte_end":1376,"line_start":48,"line_end":48,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    let nsi = sh_si.orbitals.len();","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/two_electron.rs:48:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let nsi = sh_si.orbitals.len();\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no method named `second_deriv_eri` found for reference `&Shell` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/two_electron.rs","byte_start":1815,"byte_end":1821,"line_start":58,"line_end":58,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"                        sh_mu.second_deriv_eri(","highlight_start":25,"highlight_end":31}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hessian/two_electron.rs","byte_start":1821,"byte_end":1837,"line_start":58,"line_end":58,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"                        sh_mu.second_deriv_eri(","highlight_start":31,"highlight_end":47}],"label":"method not found in `&Shell`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `second_deriv_eri` found for reference `&Shell` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/two_electron.rs:58:31\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         sh_mu.second_deriv_eri(\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[94m------\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&Shell`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/hessian/xc.rs","byte_start":2306,"byte_end":2313,"line_start":81,"line_end":81,"column_start":58,"column_end":65,"is_primary":true,"text":[{"text":"        let dp = density_at_point(shells, shell_centers, density, r);","highlight_start":58,"highlight_end":65}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hessian/xc.rs","byte_start":2266,"byte_end":2282,"line_start":81,"line_end":81,"column_start":18,"column_end":34,"is_primary":false,"text":[{"text":"        let dp = density_at_point(shells, shell_centers, density, r);","highlight_start":18,"highlight_end":34}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/density.rs","byte_start":725,"byte_end":747,"line_start":31,"line_end":31,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":649,"byte_end":665,"line_start":28,"line_end":28,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"pub fn density_at_point(","highlight_start":8,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/xc.rs:81:58\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dp = density_at_point(shells, shell_centers, density, r);\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m----------------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n              found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:28:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn density_at_point(\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hessian/xc.rs","byte_start":2606,"byte_end":2614,"line_start":91,"line_end":91,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"            for ao in &sh.orbitals {","highlight_start":27,"highlight_end":35}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/xc.rs:91:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m91\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for ao in &sh.orbitals {\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/hessian/xc.rs","byte_start":2642,"byte_end":2644,"line_start":92,"line_end":92,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"                phi.push(ao.value(*c, r));","highlight_start":26,"highlight_end":28}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/xc.rs:92:26\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 phi.push(ao.value(*c, r));\n   \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_xc_hessian` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_xc_hessian` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hessian/xc.rs","byte_start":3601,"byte_end":3616,"line_start":122,"line_end":122,"column_start":22,"column_end":37,"is_primary":true,"text":[{"text":"        let xc2 = fx.eval_xc_hessian(&rho, &sigma, tau);","highlight_start":22,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `eval_gga_hessian` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/dft/libxc.rs","byte_start":4476,"byte_end":4578,"line_start":191,"line_end":195,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn eval_gga_hessian(","highlight_start":5,"highlight_end":29},{"text":"        &self,","highlight_start":1,"highlight_end":15},{"text":"        rho: &[f64],","highlight_start":1,"highlight_end":21},{"text":"        sigma: &[f64],","highlight_start":1,"highlight_end":23},{"text":"    ) -> XcHessian {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_xc_hessian` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/xc.rs:122:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let xc2 = fx.eval_xc_hessian(&rho, &sigma, tau);\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_xc_hessian` not found for this struct\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `eval_gga_hessian` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/libxc.rs:191:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m191\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m/\u001b[0m     pub fn eval_gga_hessian(\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         &self,\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         rho: &[f64],\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         sigma: &[f64],\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     ) -> XcHessian {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|__________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_xc_hessian` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_xc_hessian` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hessian/xc.rs","byte_start":3658,"byte_end":3673,"line_start":123,"line_end":123,"column_start":22,"column_end":37,"is_primary":true,"text":[{"text":"        let cc2 = fc.eval_xc_hessian(&rho, &sigma, tau);","highlight_start":22,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `eval_gga_hessian` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/dft/libxc.rs","byte_start":4476,"byte_end":4578,"line_start":191,"line_end":195,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn eval_gga_hessian(","highlight_start":5,"highlight_end":29},{"text":"        &self,","highlight_start":1,"highlight_end":15},{"text":"        rho: &[f64],","highlight_start":1,"highlight_end":21},{"text":"        sigma: &[f64],","highlight_start":1,"highlight_end":23},{"text":"    ) -> XcHessian {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_xc_hessian` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hessian/xc.rs:123:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let cc2 = fc.eval_xc_hessian(&rho, &sigma, tau);\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_xc_hessian` not found for this struct\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `eval_gga_hessian` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/libxc.rs:191:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m191\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m/\u001b[0m     pub fn eval_gga_hessian(\n\u001b[1m\u001b[94m192\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         &self,\n\u001b[1m\u001b[94m193\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         rho: &[f64],\n\u001b[1m\u001b[94m194\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         sigma: &[f64],\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     ) -> XcHessian {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m|__________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":989,"byte_end":997,"line_start":42,"line_end":42,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"        for mu in 0..si.orbitals.len() {","highlight_start":25,"highlight_end":33}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:42:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for mu in 0..si.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":1034,"byte_end":1042,"line_start":43,"line_end":43,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"            let phi_mu = si.orbitals[mu].value(*ci, r);","highlight_start":29,"highlight_end":37}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:43:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let phi_mu = si.orbitals[mu].value(*ci, r);\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":1091,"byte_end":1099,"line_start":44,"line_end":44,"column_start":30,"column_end":38,"is_primary":true,"text":[{"text":"            let grad_mu = si.orbitals[mu].gradient(*ci, r);","highlight_start":30,"highlight_end":38}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:44:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let grad_mu = si.orbitals[mu].gradient(*ci, r);\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":1298,"byte_end":1306,"line_start":51,"line_end":51,"column_start":33,"column_end":41,"is_primary":true,"text":[{"text":"                for nu in 0..sj.orbitals.len() {","highlight_start":33,"highlight_end":41}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:51:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for nu in 0..sj.orbitals.len() {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":1351,"byte_end":1359,"line_start":52,"line_end":52,"column_start":37,"column_end":45,"is_primary":true,"text":[{"text":"                    let phi_nu = sj.orbitals[nu].value(*cj, r);","highlight_start":37,"highlight_end":45}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:52:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let phi_nu = sj.orbitals[nu].value(*cj, r);\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/density.rs","byte_start":1416,"byte_end":1424,"line_start":53,"line_end":53,"column_start":38,"column_end":46,"is_primary":true,"text":[{"text":"                    let grad_nu = sj.orbitals[nu].gradient(*cj, r);","highlight_start":38,"highlight_end":46}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:53:38\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let grad_nu = sj.orbitals[nu].gradient(*cj, r);\n   \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":2551,"byte_end":2558,"line_start":110,"line_end":110,"column_start":58,"column_end":65,"is_primary":true,"text":[{"text":"        let dp = density_at_point(shells, shell_centers, density, r);","highlight_start":58,"highlight_end":65}],"label":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/vxc.rs","byte_start":2511,"byte_end":2527,"line_start":110,"line_end":110,"column_start":18,"column_end":34,"is_primary":false,"text":[{"text":"        let dp = density_at_point(shells, shell_centers, density, r);","highlight_start":18,"highlight_end":34}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/density.rs","byte_start":725,"byte_end":747,"line_start":31,"line_end":31,"column_start":5,"column_end":27,"is_primary":false,"text":[{"text":"    density: &DMatrix<f64>,","highlight_start":5,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":649,"byte_end":665,"line_start":28,"line_end":28,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"pub fn density_at_point(","highlight_start":8,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:110:58\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dp = density_at_point(shells, shell_centers, density, r);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m----------------\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:28:8\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn density_at_point(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":2851,"byte_end":2859,"line_start":120,"line_end":120,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"            for ao in &sh.orbitals {","highlight_start":27,"highlight_end":35}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:120:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for ao in &sh.orbitals {\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":2887,"byte_end":2889,"line_start":121,"line_end":121,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"                phi.push(ao.value(*c, r));","highlight_start":26,"highlight_end":28}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:121:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 phi.push(ao.value(*c, r));\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_all` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":3533,"byte_end":3541,"line_start":142,"line_end":142,"column_start":43,"column_end":51,"is_primary":true,"text":[{"text":"        let (eps_x, vrx, vsx, vtx_x) = fx.eval_all(&rho, &sigma, tau);","highlight_start":43,"highlight_end":51}],"label":"method not found in `LibXC`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_all` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_all` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:142:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m142\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (eps_x, vrx, vsx, vtx_x) = fx.eval_all(&rho, &sigma, tau);\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `LibXC`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_all` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_all` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":3604,"byte_end":3612,"line_start":143,"line_end":143,"column_start":43,"column_end":51,"is_primary":true,"text":[{"text":"        let (eps_c, vrc, vsc, vtx_c) = fc.eval_all(&rho, &sigma, tau);","highlight_start":43,"highlight_end":51}],"label":"method not found in `LibXC`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_all` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_all` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:143:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (eps_c, vrc, vsc, vtx_c) = fc.eval_all(&rho, &sigma, tau);\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `LibXC`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_all` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":6333,"byte_end":6354,"line_start":240,"line_end":240,"column_start":18,"column_end":39,"is_primary":true,"text":[{"text":"        let dp = spin_density_at_point(","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/dft/vxc.rs","byte_start":6415,"byte_end":6422,"line_start":243,"line_end":243,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"            p_alpha,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[{"file_name":"src/dft/vxc.rs","byte_start":6436,"byte_end":6442,"line_start":244,"line_end":244,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"            p_beta,","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected reference `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`\n   found reference `&Vec<Vec<f64>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"src/dft/density.rs","byte_start":2136,"byte_end":2164,"line_start":81,"line_end":81,"column_start":5,"column_end":33,"is_primary":false,"text":[{"text":"    density_alpha: &DMatrix<f64>,","highlight_start":5,"highlight_end":33}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":2170,"byte_end":2197,"line_start":82,"line_end":82,"column_start":5,"column_end":32,"is_primary":false,"text":[{"text":"    density_beta: &DMatrix<f64>,","highlight_start":5,"highlight_end":32}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/density.rs","byte_start":2055,"byte_end":2076,"line_start":78,"line_end":78,"column_start":8,"column_end":29,"is_primary":true,"text":[{"text":"pub fn spin_density_at_point(","highlight_start":8,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:240:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let dp = spin_density_at_point(\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:243:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m243\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             p_alpha,\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&Matrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>`, found `&Vec<Vec<f64>>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:244:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             p_beta,\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[92m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `&\u001b[1m\u001b[35mMatrix<f64, Dyn, Dyn, VecStorage<f64, Dyn, Dyn>>\u001b[0m`\n               found reference `&\u001b[1m\u001b[35mVec<Vec<f64>>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/density.rs:78:8\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn spin_density_at_point(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density_alpha: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m----------------------------\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     density_beta: &DMatrix<f64>,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":6756,"byte_end":6764,"line_start":257,"line_end":257,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"            for ao in &sh.orbitals {","highlight_start":27,"highlight_end":35}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:257:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m257\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for ao in &sh.orbitals {\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":6792,"byte_end":6794,"line_start":258,"line_end":258,"column_start":26,"column_end":28,"is_primary":true,"text":[{"text":"                phi.push(ao.value(*c, r));","highlight_start":26,"highlight_end":28}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:258:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 phi.push(ao.value(*c, r));\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_all_spin` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":7623,"byte_end":7636,"line_start":279,"line_end":279,"column_start":43,"column_end":56,"is_primary":true,"text":[{"text":"        let (eps_x, vrx, vsx, vtx_x) = fx.eval_all_spin(&rho, &sigma, &tau);","highlight_start":43,"highlight_end":56}],"label":"method not found in `LibXC`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_all_spin` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_all_spin` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:279:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (eps_x, vrx, vsx, vtx_x) = fx.eval_all_spin(&rho, &sigma, &tau);\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `LibXC`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_all_spin` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `eval_all_spin` found for struct `LibXC` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/vxc.rs","byte_start":7700,"byte_end":7713,"line_start":280,"line_end":280,"column_start":43,"column_end":56,"is_primary":true,"text":[{"text":"        let (eps_c, vrc, vsc, vtx_c) = fc.eval_all_spin(&rho, &sigma, &tau);","highlight_start":43,"highlight_end":56}],"label":"method not found in `LibXC`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/dft/libxc.rs","byte_start":2280,"byte_end":2296,"line_start":103,"line_end":103,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub struct LibXC {","highlight_start":1,"highlight_end":17}],"label":"method `eval_all_spin` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `eval_all_spin` found for struct `LibXC` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/dft/vxc.rs:280:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let (eps_c, vrc, vsc, vtx_c) = fc.eval_all_spin(&rho, &sigma, &tau);\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `LibXC`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/dft/libxc.rs:103:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct LibXC {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mmethod `eval_all_spin` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/tau.rs","byte_start":468,"byte_end":476,"line_start":18,"line_end":18,"column_start":23,"column_end":31,"is_primary":true,"text":[{"text":"        for ao in &sh.orbitals {","highlight_start":23,"highlight_end":31}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/tau.rs:18:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for ao in &sh.orbitals {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/dft/tau.rs","byte_start":505,"byte_end":507,"line_start":19,"line_end":19,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"            grad_phi.push(ao.gradient(*c, r));","highlight_start":27,"highlight_end":29}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/tau.rs:19:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             grad_phi.push(ao.gradient(*c, r));\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `orbitals` on type `&Shell`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/dft/tau.rs","byte_start":1313,"byte_end":1321,"line_start":51,"line_end":51,"column_start":23,"column_end":31,"is_primary":true,"text":[{"text":"        for ao in &sh.orbitals {","highlight_start":23,"highlight_end":31}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `primitives`, `ang`, `center`, `offset`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `orbitals` on type `&Shell`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/tau.rs:51:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for ao in &sh.orbitals {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `primitives`, `ang`, `center`, `offset`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/dft/tau.rs","byte_start":1350,"byte_end":1352,"line_start":52,"line_end":52,"column_start":27,"column_end":29,"is_primary":true,"text":[{"text":"            grad_phi.push(ao.gradient(*c, r));","highlight_start":27,"highlight_end":29}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/dft/tau.rs:52:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             grad_phi.push(ao.gradient(*c, r));\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `pi`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/integrals/eri/eri_vrr.rs","byte_start":1249,"byte_end":1251,"line_start":61,"line_end":61,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"    let pi = eri_psss(a, b, c, d, i);","highlight_start":9,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/integrals/eri/eri_vrr.rs","byte_start":1249,"byte_end":1251,"line_start":61,"line_end":61,"column_start":9,"column_end":11,"is_primary":true,"text":[{"text":"    let pi = eri_psss(a, b, c, d, i);","highlight_start":9,"highlight_end":11}],"label":null,"suggested_replacement":"_pi","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `pi`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/eri/eri_vrr.rs:61:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let pi = eri_psss(a, b, c, d, i);\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_pi`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `pij`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/integrals/eri/eri_vrr.rs","byte_start":1784,"byte_end":1787,"line_start":87,"line_end":87,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"    let pij = eri_ppss(a, b, c, d, i, j);","highlight_start":9,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/integrals/eri/eri_vrr.rs","byte_start":1784,"byte_end":1787,"line_start":87,"line_end":87,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"    let pij = eri_ppss(a, b, c, d, i, j);","highlight_start":9,"highlight_end":12}],"label":null,"suggested_replacement":"_pij","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `pij`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/integrals/eri/eri_vrr.rs:87:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let pij = eri_ppss(a, b, c, d, i, j);\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_pij`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `shell_centers`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/scf/jk.rs","byte_start":361,"byte_end":374,"line_start":13,"line_end":13,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    shell_centers: &[[f64; 3]],","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/scf/jk.rs","byte_start":361,"byte_end":374,"line_start":13,"line_end":13,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    shell_centers: &[[f64; 3]],","highlight_start":5,"highlight_end":18}],"label":null,"suggested_replacement":"_shell_centers","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `shell_centers`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/scf/jk.rs:13:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shell_centers: &[[f64; 3]],\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_shell_centers`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `shells`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/gradients/two_electron.rs","byte_start":92,"byte_end":98,"line_start":5,"line_end":5,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    shells: &[Shell],","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/gradients/two_electron.rs","byte_start":92,"byte_end":98,"line_start":5,"line_end":5,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    shells: &[Shell],","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":"_shells","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `shells`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/gradients/two_electron.rs:5:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     shells: &[Shell],\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_shells`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `natoms`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/vibrations/mass.rs","byte_start":167,"byte_end":173,"line_start":9,"line_end":9,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"    let natoms = masses.len();","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/vibrations/mass.rs","byte_start":167,"byte_end":173,"line_start":9,"line_end":9,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"    let natoms = masses.len();","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":"_natoms","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `natoms`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/vibrations/mass.rs:9:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let natoms = masses.len();\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_natoms`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 138 previous errors; 15 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 138 previous errors; 15 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0282, E0308, E0425, E0593, E0599, E0608, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0282, E0308, E0425, E0593, E0599, E0608, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
